{"version":3,"sources":["webpack:////Developer/Work/SPA/ngx-starter-kit/libs/breadcrumbs/src/lib/breadcrumbs.module.ts","webpack:////Developer/Work/SPA/ngx-starter-kit/node_modules/@angular/cdk/esm2015/drag-drop.js.pre-build-optimizer.js","webpack:////Developer/Work/SPA/ngx-starter-kit/libs/breadcrumbs/src/lib/breadcrumbs.component.ts","webpack:////Developer/Work/SPA/ngx-starter-kit/libs/breadcrumbs/src/lib/breadcrumbs.component.scss.shim.ngstyle.js.pre-build-optimizer.js","webpack:////Developer/Work/SPA/ngx-starter-kit/libs/breadcrumbs/src/lib/breadcrumbs.component.ngfactory.js.pre-build-optimizer.js","webpack:////Developer/Work/SPA/ngx-starter-kit/libs/breadcrumbs/src/lib/breadcrumbs.component.html"],"names":["__webpack_require__","d","__webpack_exports__","BreadcrumbsModule","DragDrop","CdkDropList","CDK_DROP_LIST","moveItemInArray","DragDropModule","DragDropRegistry","CdkDropListGroup","CDK_DRAG_CONFIG","CdkDrag","CdkDragHandle","CDK_DRAG_PARENT","_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_0__","_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_1__","rxjs__WEBPACK_IMPORTED_MODULE_2__","rxjs__WEBPACK_IMPORTED_MODULE_3__","rxjs__WEBPACK_IMPORTED_MODULE_4__","rxjs__WEBPACK_IMPORTED_MODULE_5__","_angular_core__WEBPACK_IMPORTED_MODULE_6__","_angular_common__WEBPACK_IMPORTED_MODULE_7__","_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_8__","rxjs_operators__WEBPACK_IMPORTED_MODULE_9__","rxjs_operators__WEBPACK_IMPORTED_MODULE_10__","rxjs_operators__WEBPACK_IMPORTED_MODULE_11__","rxjs_operators__WEBPACK_IMPORTED_MODULE_12__","rxjs_operators__WEBPACK_IMPORTED_MODULE_13__","rxjs_operators__WEBPACK_IMPORTED_MODULE_14__","extendStyles","dest","source","key","hasOwnProperty","toggleNativeDragInteractions","element","enable","userSelect","style","touchAction","webkitUserDrag","webkitTapHighlightColor","msUserSelect","webkitUserSelect","MozUserSelect","parseCssTimeUnitsToMs","value","multiplier","toLowerCase","indexOf","parseFloat","parseCssPropertyValue","computedStyle","name","getPropertyValue","split","map","part","trim","passiveEventListenerOptions","Object","passive","activeEventListenerOptions","MOUSE_EVENT_IGNORE_TIME","DragRef","[object Object]","_config","_document","_ngZone","_viewportRuler","_dragDropRegistry","this","_passiveTransform","x","y","_activeTransform","_moveEvents","_moveEventSubscriptions","_pointerMoveSubscription","EMPTY","_pointerUpSubscription","_boundaryElement","_nativeInteractionsEnabled","_handles","_disabledHandles","Set","_direction","dragStartDelay","_disabled","beforeStarted","started","released","ended","entered","exited","dropped","moved","observer","subscription","subscribe","unsubscribe","_pointerDown","event","next","length","targetHandle","find","handle","target","contains","has","disabled","_initializeDragSequence","_rootElement","_pointerMove","_hasStartedDragging","pointerPosition","_getPointerPositionOnPage","Math","abs","_pickupPositionOnPage","dragStartThreshold","Date","now","_dragStartTime","run","_startDragSequence","_previewRect","width","height","_preview","getBoundingClientRect","constrainedPointerPosition","_getConstrainedPointerPosition","_hasMoved","preventDefault","_updatePointerDirectionDelta","_dropContainer","_updateActiveDropContainer","activeTransform","_applyRootElementTransform","SVGElement","setAttribute","delta","_pointerDirectionDelta","_pointerUp","isDragging","_removeSubscriptions","stopDragging","_rootElementTapHighlight","_animatePreviewToPlaceholder","then","_cleanupDragArtifacts","withRootElement","registerDragItem","newValue","_toggleNativeDragInteractions","_placeholder","handles","forEach","template","_previewTemplate","_placeholderTemplate","rootElement","_removeRootElementListeners","addEventListener","_initialTransform","undefined","boundaryElement","removeElement","_destroyPreview","_destroyPlaceholder","removeDragItem","complete","clear","_nextSibling","transform","add","delete","direction","container","_previewRef","destroy","_placeholderRef","isTouchEvent","_lastTouchEventTime","nextSibling","preview","_createPreviewElement","placeholder","_createPlaceholderElement","display","body","appendChild","replaceChild","documentRef","fullscreenElement","webkitFullscreenElement","mozFullScreenElement","msFullscreenElement","start","referenceElement","stopPropagation","isTouchSequence","isAuxiliaryMouseButton","button","isSyntheticEvent","draggable","type","_initialContainer","pointerMove","pointerUp","_scrollPosition","getViewportScrollPosition","_boundaryRect","_pickupPositionInElement","_getPointerPositionInElement","_pointerPositionAtLastDirectionChange","startDragging","insertBefore","currentIndex","getItemIndex","isPointerOverContainer","_isOverContainer","item","previousIndex","previousContainer","drop","newContainer","_getSiblingContainerFromPosition","exit","enter","_sortItem","getTransform","previewConfig","previewTemplate","viewRef","viewContainer","createEmbeddedView","context","rootNodes","elementRect","deepCloneNode","left","top","pointerEvents","position","zIndex","classList","Promise","resolve","placeholderRect","duration","getComputedStyle","transitionedProperties","property","prop","propertyIndex","rawDurations","rawDelays","getTransformTransitionDurationInMs","runOutsideAngular","handler","propertyName","removeEventListener","clearTimeout","timeout","setTimeout","placeholderConfig","placeholderTemplate","handleElement","referenceRect","point","targetTouches","pageX","pageY","touches","changedTouches","constrainedPoint","constrainPosition","dropContainerLock","lockAxis","pickupX","pickupY","boundaryRect","previewRect","minY","maxY","bottom","clamp","right","pointerPositionOnPage","positionSinceLastChange","changeX","changeY","pointerDirectionChangeThreshold","shouldEnable","round","node","clone","cloneNode","descendantsWithId","querySelectorAll","removeAttribute","i","min","max","parentNode","removeChild","startsWith","array","fromIndex","toIndex","from","clamp$1","to","_uniqueIdCounter","DROP_PROXIMITY_THRESHOLD","DropListRef","id","sortingDisabled","enterPredicate","sorted","_isDragging","_itemPositions","_previousSwap","drag","_siblings","_orientation","_activeSiblings","registerDropContainer","nativeElement","removeDropContainer","_activeDraggables","_draggables","slice","_cacheOwnPosition","_cacheItemPositions","sibling","_startReceiving","pointerX","pointerY","newIndex","_getItemIndexFromPointerPosition","activeDraggables","getPlaceholderElement","newPositionReference","splice","getRootElement","push","_reset","items","_withDropContainer","connectedTo","orientation","findIndex","reverse","currentItem","size","pointerDelta","_isPointerNearDropContainer","siblings","isHorizontal","siblingAtNewPosition","currentPosition","clientRect","newPosition","itemOffset","_getItemOffsetPx","siblingOffset","_getSiblingOffsetPx","oldOrder","index","isDraggedItem","offset","elementToOffset","adjustClientRect","_clientRect","sort","a","b","_stopReceiving","immediateSibling","end","xThreshold","yThreshold","_","floor","isInsideClientRect","_canReceive","elementFromPoint","activeSiblings","predicate","activeCapturingEventOptions","capture","_dropInstances","_dragInstances","_activeDragInstances","_globalListeners","Map","_preventDefaultWhileDragging","getDropContainer","Error","upEvent","set","e","options","config","_clearGlobalListeners","Array","instance","ngInjectableDef","factory","token","providedIn","DEFAULT_CONFIG","parentDrag","_stateChanges","_parentDrag","dropContainer","_viewContainerRef","_dir","dragDrop","_changeDetectorRef","_destroyed","_dragRef","pipe","movedEvent","createDrag","data","_syncInputs","_handleEvents","reset","getFreeDragPosition","onStable","asObservable","_updateRootElement","changes","childHandleElements","filter","withHandles","handleInstance","dragRef","disableHandle","enableHandle","freeDragPosition","setFreeDragPosition","rootSelectorChange","positionChange","firstChange","dispose","rootElementSelector","getClosestMatchingAncestor","nodeType","ELEMENT_NODE","nodeName","selector","boundaryElementSelector","ref","dir","templateRef","withBoundaryElement","_getBoundaryElement","withPlaceholderTemplate","withPreviewTemplate","withDirection","emit","markForCheck","currentElement","matches","msMatchesSelector","parentElement","_items","_uniqueIdCounter$1","_group","_sortingDisabled","_dropListRef","createDropList","_dropLists","withItems","result","change","list","withOrientation","BreadcrumbsComponent","RenderType_BreadcrumbsComponent","View_BreadcrumbsComponent_0","core","encapsulation","styles","View_BreadcrumbsComponent_2","_l","_v","en","$event","ad","onClick","ctrlKey","metaKey","shiftKey","router","common","routerLink","_ck","currVal_2","parent","$implicit","link","href","View_BreadcrumbsComponent_3","View_BreadcrumbsComponent_4","index_ngfactory","icon","inline","color","View_BreadcrumbsComponent_1","flex","esm2015_core","fxLayout","fxLayoutAlign","ngSwitch","ngSwitchCase","ngIf","last","ngForOf","_co","component","crumbs","title"],"mappings":"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","file":"8-es2015.c8ac01caa1d617afd0e1.js","sourcesContent":["import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { BreadcrumbsComponent } from './breadcrumbs.component';\nimport { MatIconModule } from '@angular/material/icon';\nimport { RouterModule } from '@angular/router';\nimport { FlexLayoutModule } from '@angular/flex-layout';\n\n@NgModule({\n  imports: [MatIconModule, FlexLayoutModule, RouterModule, CommonModule],\n  exports: [BreadcrumbsComponent],\n  declarations: [BreadcrumbsComponent],\n})\nexport class BreadcrumbsModule {}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { normalizePassiveListenerOptions } from '@angular/cdk/platform';\nimport { coerceBooleanProperty, coerceElement, coerceNumberProperty, coerceArray } from '@angular/cdk/coercion';\nimport { Subscription, Subject, Observable, merge } from 'rxjs';\nimport { ElementRef, Injectable, NgZone, Inject, InjectionToken, NgModule, ContentChildren, EventEmitter, forwardRef, Input, Output, Optional, Directive, ChangeDetectorRef, SkipSelf, ContentChild, ViewContainerRef, TemplateRef, ɵɵdefineInjectable, ɵɵinject } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\nimport { ViewportRuler } from '@angular/cdk/scrolling';\nimport { Directionality } from '@angular/cdk/bidi';\nimport { startWith, take, map, takeUntil, switchMap, tap } from 'rxjs/operators';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Shallow-extends a stylesheet object with another stylesheet object.\n * \\@docs-private\n * @param {?} dest\n * @param {?} source\n * @return {?}\n */\nfunction extendStyles(dest, source) {\n    for (let key in source) {\n        if (source.hasOwnProperty(key)) {\n            dest[(/** @type {?} */ (key))] = source[(/** @type {?} */ (key))];\n        }\n    }\n    return dest;\n}\n/**\n * Toggles whether the native drag interactions should be enabled for an element.\n * \\@docs-private\n * @param {?} element Element on which to toggle the drag interactions.\n * @param {?} enable Whether the drag interactions should be enabled.\n * @return {?}\n */\nfunction toggleNativeDragInteractions(element, enable) {\n    /** @type {?} */\n    const userSelect = enable ? '' : 'none';\n    extendStyles(element.style, {\n        touchAction: enable ? '' : 'none',\n        webkitUserDrag: enable ? '' : 'none',\n        webkitTapHighlightColor: enable ? '' : 'transparent',\n        userSelect: userSelect,\n        msUserSelect: userSelect,\n        webkitUserSelect: userSelect,\n        MozUserSelect: userSelect\n    });\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Parses a CSS time value to milliseconds.\n * @param {?} value\n * @return {?}\n */\nfunction parseCssTimeUnitsToMs(value) {\n    // Some browsers will return it in seconds, whereas others will return milliseconds.\n    /** @type {?} */\n    const multiplier = value.toLowerCase().indexOf('ms') > -1 ? 1 : 1000;\n    return parseFloat(value) * multiplier;\n}\n/**\n * Gets the transform transition duration, including the delay, of an element in milliseconds.\n * @param {?} element\n * @return {?}\n */\nfunction getTransformTransitionDurationInMs(element) {\n    /** @type {?} */\n    const computedStyle = getComputedStyle(element);\n    /** @type {?} */\n    const transitionedProperties = parseCssPropertyValue(computedStyle, 'transition-property');\n    /** @type {?} */\n    const property = transitionedProperties.find((/**\n     * @param {?} prop\n     * @return {?}\n     */\n    prop => prop === 'transform' || prop === 'all'));\n    // If there's no transition for `all` or `transform`, we shouldn't do anything.\n    if (!property) {\n        return 0;\n    }\n    // Get the index of the property that we're interested in and match\n    // it up to the same index in `transition-delay` and `transition-duration`.\n    /** @type {?} */\n    const propertyIndex = transitionedProperties.indexOf(property);\n    /** @type {?} */\n    const rawDurations = parseCssPropertyValue(computedStyle, 'transition-duration');\n    /** @type {?} */\n    const rawDelays = parseCssPropertyValue(computedStyle, 'transition-delay');\n    return parseCssTimeUnitsToMs(rawDurations[propertyIndex]) +\n        parseCssTimeUnitsToMs(rawDelays[propertyIndex]);\n}\n/**\n * Parses out multiple values from a computed style into an array.\n * @param {?} computedStyle\n * @param {?} name\n * @return {?}\n */\nfunction parseCssPropertyValue(computedStyle, name) {\n    /** @type {?} */\n    const value = computedStyle.getPropertyValue(name);\n    return value.split(',').map((/**\n     * @param {?} part\n     * @return {?}\n     */\n    part => part.trim()));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Options that can be used to bind a passive event listener.\n * @type {?}\n */\nconst passiveEventListenerOptions = normalizePassiveListenerOptions({ passive: true });\n/**\n * Options that can be used to bind an active event listener.\n * @type {?}\n */\nconst activeEventListenerOptions = normalizePassiveListenerOptions({ passive: false });\n/**\n * Time in milliseconds for which to ignore mouse events, after\n * receiving a touch event. Used to avoid doing double work for\n * touch devices where the browser fires fake mouse events, in\n * addition to touch events.\n * @type {?}\n */\nconst MOUSE_EVENT_IGNORE_TIME = 800;\n/**\n * Reference to a draggable item. Used to manipulate or dispose of the item.\n * \\@docs-private\n * @template T\n */\nclass DragRef {\n    /**\n     * @param {?} element\n     * @param {?} _config\n     * @param {?} _document\n     * @param {?} _ngZone\n     * @param {?} _viewportRuler\n     * @param {?} _dragDropRegistry\n     */\n    constructor(element, _config, _document, _ngZone, _viewportRuler, _dragDropRegistry) {\n        this._config = _config;\n        this._document = _document;\n        this._ngZone = _ngZone;\n        this._viewportRuler = _viewportRuler;\n        this._dragDropRegistry = _dragDropRegistry;\n        /**\n         * CSS `transform` applied to the element when it isn't being dragged. We need a\n         * passive transform in order for the dragged element to retain its new position\n         * after the user has stopped dragging and because we need to know the relative\n         * position in case they start dragging again. This corresponds to `element.style.transform`.\n         */\n        this._passiveTransform = { x: 0, y: 0 };\n        /**\n         * CSS `transform` that is applied to the element while it's being dragged.\n         */\n        this._activeTransform = { x: 0, y: 0 };\n        /**\n         * Emits when the item is being moved.\n         */\n        this._moveEvents = new Subject();\n        /**\n         * Amount of subscriptions to the move event. Used to avoid\n         * hitting the zone if the consumer didn't subscribe to it.\n         */\n        this._moveEventSubscriptions = 0;\n        /**\n         * Subscription to pointer movement events.\n         */\n        this._pointerMoveSubscription = Subscription.EMPTY;\n        /**\n         * Subscription to the event that is dispatched when the user lifts their pointer.\n         */\n        this._pointerUpSubscription = Subscription.EMPTY;\n        /**\n         * Cached reference to the boundary element.\n         */\n        this._boundaryElement = null;\n        /**\n         * Whether the native dragging interactions have been enabled on the root element.\n         */\n        this._nativeInteractionsEnabled = true;\n        /**\n         * Elements that can be used to drag the draggable item.\n         */\n        this._handles = [];\n        /**\n         * Registered handles that are currently disabled.\n         */\n        this._disabledHandles = new Set();\n        /**\n         * Layout direction of the item.\n         */\n        this._direction = 'ltr';\n        /**\n         * Amount of milliseconds to wait after the user has put their\n         * pointer down before starting to drag the element.\n         */\n        this.dragStartDelay = 0;\n        this._disabled = false;\n        /**\n         * Emits as the drag sequence is being prepared.\n         */\n        this.beforeStarted = new Subject();\n        /**\n         * Emits when the user starts dragging the item.\n         */\n        this.started = new Subject();\n        /**\n         * Emits when the user has released a drag item, before any animations have started.\n         */\n        this.released = new Subject();\n        /**\n         * Emits when the user stops dragging an item in the container.\n         */\n        this.ended = new Subject();\n        /**\n         * Emits when the user has moved the item into a new container.\n         */\n        this.entered = new Subject();\n        /**\n         * Emits when the user removes the item its container by dragging it into another container.\n         */\n        this.exited = new Subject();\n        /**\n         * Emits when the user drops the item inside a container.\n         */\n        this.dropped = new Subject();\n        /**\n         * Emits as the user is dragging the item. Use with caution,\n         * because this event will fire for every pixel that the user has dragged.\n         */\n        this.moved = new Observable((/**\n         * @param {?} observer\n         * @return {?}\n         */\n        (observer) => {\n            /** @type {?} */\n            const subscription = this._moveEvents.subscribe(observer);\n            this._moveEventSubscriptions++;\n            return (/**\n             * @return {?}\n             */\n            () => {\n                subscription.unsubscribe();\n                this._moveEventSubscriptions--;\n            });\n        }));\n        /**\n         * Handler for the `mousedown`/`touchstart` events.\n         */\n        this._pointerDown = (/**\n         * @param {?} event\n         * @return {?}\n         */\n        (event) => {\n            this.beforeStarted.next();\n            // Delegate the event based on whether it started from a handle or the element itself.\n            if (this._handles.length) {\n                /** @type {?} */\n                const targetHandle = this._handles.find((/**\n                 * @param {?} handle\n                 * @return {?}\n                 */\n                handle => {\n                    /** @type {?} */\n                    const target = event.target;\n                    return !!target && (target === handle || handle.contains((/** @type {?} */ (target))));\n                }));\n                if (targetHandle && !this._disabledHandles.has(targetHandle) && !this.disabled) {\n                    this._initializeDragSequence(targetHandle, event);\n                }\n            }\n            else if (!this.disabled) {\n                this._initializeDragSequence(this._rootElement, event);\n            }\n        });\n        /**\n         * Handler that is invoked when the user moves their pointer after they've initiated a drag.\n         */\n        this._pointerMove = (/**\n         * @param {?} event\n         * @return {?}\n         */\n        (event) => {\n            if (!this._hasStartedDragging) {\n                /** @type {?} */\n                const pointerPosition = this._getPointerPositionOnPage(event);\n                /** @type {?} */\n                const distanceX = Math.abs(pointerPosition.x - this._pickupPositionOnPage.x);\n                /** @type {?} */\n                const distanceY = Math.abs(pointerPosition.y - this._pickupPositionOnPage.y);\n                /** @type {?} */\n                const isOverThreshold = distanceX + distanceY >= this._config.dragStartThreshold;\n                // Only start dragging after the user has moved more than the minimum distance in either\n                // direction. Note that this is preferrable over doing something like `skip(minimumDistance)`\n                // in the `pointerMove` subscription, because we're not guaranteed to have one move event\n                // per pixel of movement (e.g. if the user moves their pointer quickly).\n                if (isOverThreshold && (Date.now() >= this._dragStartTime + (this.dragStartDelay || 0))) {\n                    this._hasStartedDragging = true;\n                    this._ngZone.run((/**\n                     * @return {?}\n                     */\n                    () => this._startDragSequence(event)));\n                }\n                return;\n            }\n            // We only need the preview dimensions if we have a boundary element.\n            if (this._boundaryElement) {\n                // Cache the preview element rect if we haven't cached it already or if\n                // we cached it too early before the element dimensions were computed.\n                if (!this._previewRect || (!this._previewRect.width && !this._previewRect.height)) {\n                    this._previewRect = (this._preview || this._rootElement).getBoundingClientRect();\n                }\n            }\n            /** @type {?} */\n            const constrainedPointerPosition = this._getConstrainedPointerPosition(event);\n            this._hasMoved = true;\n            event.preventDefault();\n            this._updatePointerDirectionDelta(constrainedPointerPosition);\n            if (this._dropContainer) {\n                this._updateActiveDropContainer(constrainedPointerPosition);\n            }\n            else {\n                /** @type {?} */\n                const activeTransform = this._activeTransform;\n                activeTransform.x =\n                    constrainedPointerPosition.x - this._pickupPositionOnPage.x + this._passiveTransform.x;\n                activeTransform.y =\n                    constrainedPointerPosition.y - this._pickupPositionOnPage.y + this._passiveTransform.y;\n                this._applyRootElementTransform(activeTransform.x, activeTransform.y);\n                // Apply transform as attribute if dragging and svg element to work for IE\n                if (typeof SVGElement !== 'undefined' && this._rootElement instanceof SVGElement) {\n                    /** @type {?} */\n                    const appliedTransform = `translate(${activeTransform.x} ${activeTransform.y})`;\n                    this._rootElement.setAttribute('transform', appliedTransform);\n                }\n            }\n            // Since this event gets fired for every pixel while dragging, we only\n            // want to fire it if the consumer opted into it. Also we have to\n            // re-enter the zone because we run all of the events on the outside.\n            if (this._moveEventSubscriptions > 0) {\n                this._ngZone.run((/**\n                 * @return {?}\n                 */\n                () => {\n                    this._moveEvents.next({\n                        source: this,\n                        pointerPosition: constrainedPointerPosition,\n                        event,\n                        delta: this._pointerDirectionDelta\n                    });\n                }));\n            }\n        });\n        /**\n         * Handler that is invoked when the user lifts their pointer up, after initiating a drag.\n         */\n        this._pointerUp = (/**\n         * @param {?} event\n         * @return {?}\n         */\n        (event) => {\n            // Note that here we use `isDragging` from the service, rather than from `this`.\n            // The difference is that the one from the service reflects whether a dragging sequence\n            // has been initiated, whereas the one on `this` includes whether the user has passed\n            // the minimum dragging threshold.\n            if (!this._dragDropRegistry.isDragging(this)) {\n                return;\n            }\n            this._removeSubscriptions();\n            this._dragDropRegistry.stopDragging(this);\n            if (this._handles) {\n                this._rootElement.style.webkitTapHighlightColor = this._rootElementTapHighlight;\n            }\n            if (!this._hasStartedDragging) {\n                return;\n            }\n            this.released.next({ source: this });\n            if (!this._dropContainer) {\n                // Convert the active transform into a passive one. This means that next time\n                // the user starts dragging the item, its position will be calculated relatively\n                // to the new passive transform.\n                this._passiveTransform.x = this._activeTransform.x;\n                this._passiveTransform.y = this._activeTransform.y;\n                this._ngZone.run((/**\n                 * @return {?}\n                 */\n                () => this.ended.next({ source: this })));\n                this._dragDropRegistry.stopDragging(this);\n                return;\n            }\n            this._animatePreviewToPlaceholder().then((/**\n             * @return {?}\n             */\n            () => {\n                this._cleanupDragArtifacts(event);\n                this._dragDropRegistry.stopDragging(this);\n            }));\n        });\n        this.withRootElement(element);\n        _dragDropRegistry.registerDragItem(this);\n    }\n    /**\n     * Whether starting to drag this element is disabled.\n     * @return {?}\n     */\n    get disabled() {\n        return this._disabled || !!(this._dropContainer && this._dropContainer.disabled);\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set disabled(value) {\n        /** @type {?} */\n        const newValue = coerceBooleanProperty(value);\n        if (newValue !== this._disabled) {\n            this._disabled = newValue;\n            this._toggleNativeDragInteractions();\n        }\n    }\n    /**\n     * Returns the element that is being used as a placeholder\n     * while the current element is being dragged.\n     * @return {?}\n     */\n    getPlaceholderElement() {\n        return this._placeholder;\n    }\n    /**\n     * Returns the root draggable element.\n     * @return {?}\n     */\n    getRootElement() {\n        return this._rootElement;\n    }\n    /**\n     * Registers the handles that can be used to drag the element.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} handles\n     * @return {THIS}\n     */\n    withHandles(handles) {\n        (/** @type {?} */ (this))._handles = handles.map((/**\n         * @param {?} handle\n         * @return {?}\n         */\n        handle => coerceElement(handle)));\n        (/** @type {?} */ (this))._handles.forEach((/**\n         * @param {?} handle\n         * @return {?}\n         */\n        handle => toggleNativeDragInteractions(handle, false)));\n        (/** @type {?} */ (this))._toggleNativeDragInteractions();\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Registers the template that should be used for the drag preview.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} template Template that from which to stamp out the preview.\n     * @return {THIS}\n     */\n    withPreviewTemplate(template) {\n        (/** @type {?} */ (this))._previewTemplate = template;\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Registers the template that should be used for the drag placeholder.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} template Template that from which to stamp out the placeholder.\n     * @return {THIS}\n     */\n    withPlaceholderTemplate(template) {\n        (/** @type {?} */ (this))._placeholderTemplate = template;\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Sets an alternate drag root element. The root element is the element that will be moved as\n     * the user is dragging. Passing an alternate root element is useful when trying to enable\n     * dragging on an element that you might not have access to.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} rootElement\n     * @return {THIS}\n     */\n    withRootElement(rootElement) {\n        /** @type {?} */\n        const element = coerceElement(rootElement);\n        if (element !== (/** @type {?} */ (this))._rootElement) {\n            if ((/** @type {?} */ (this))._rootElement) {\n                (/** @type {?} */ (this))._removeRootElementListeners((/** @type {?} */ (this))._rootElement);\n            }\n            element.addEventListener('mousedown', (/** @type {?} */ (this))._pointerDown, activeEventListenerOptions);\n            element.addEventListener('touchstart', (/** @type {?} */ (this))._pointerDown, passiveEventListenerOptions);\n            (/** @type {?} */ (this))._initialTransform = undefined;\n            (/** @type {?} */ (this))._rootElement = element;\n        }\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Element to which the draggable's position will be constrained.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} boundaryElement\n     * @return {THIS}\n     */\n    withBoundaryElement(boundaryElement) {\n        (/** @type {?} */ (this))._boundaryElement = boundaryElement ? coerceElement(boundaryElement) : null;\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Removes the dragging functionality from the DOM element.\n     * @return {?}\n     */\n    dispose() {\n        this._removeRootElementListeners(this._rootElement);\n        // Do this check before removing from the registry since it'll\n        // stop being considered as dragged once it is removed.\n        if (this.isDragging()) {\n            // Since we move out the element to the end of the body while it's being\n            // dragged, we have to make sure that it's removed if it gets destroyed.\n            removeElement(this._rootElement);\n        }\n        this._destroyPreview();\n        this._destroyPlaceholder();\n        this._dragDropRegistry.removeDragItem(this);\n        this._removeSubscriptions();\n        this.beforeStarted.complete();\n        this.started.complete();\n        this.released.complete();\n        this.ended.complete();\n        this.entered.complete();\n        this.exited.complete();\n        this.dropped.complete();\n        this._moveEvents.complete();\n        this._handles = [];\n        this._disabledHandles.clear();\n        this._dropContainer = undefined;\n        this._boundaryElement = this._rootElement = this._placeholderTemplate =\n            this._previewTemplate = this._nextSibling = (/** @type {?} */ (null));\n    }\n    /**\n     * Checks whether the element is currently being dragged.\n     * @return {?}\n     */\n    isDragging() {\n        return this._hasStartedDragging && this._dragDropRegistry.isDragging(this);\n    }\n    /**\n     * Resets a standalone drag item to its initial position.\n     * @return {?}\n     */\n    reset() {\n        this._rootElement.style.transform = this._initialTransform || '';\n        this._activeTransform = { x: 0, y: 0 };\n        this._passiveTransform = { x: 0, y: 0 };\n    }\n    /**\n     * Sets a handle as disabled. While a handle is disabled, it'll capture and interrupt dragging.\n     * @param {?} handle Handle element that should be disabled.\n     * @return {?}\n     */\n    disableHandle(handle) {\n        if (this._handles.indexOf(handle) > -1) {\n            this._disabledHandles.add(handle);\n        }\n    }\n    /**\n     * Enables a handle, if it has been disabled.\n     * @param {?} handle Handle element to be enabled.\n     * @return {?}\n     */\n    enableHandle(handle) {\n        this._disabledHandles.delete(handle);\n    }\n    /**\n     * Sets the layout direction of the draggable item.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} direction\n     * @return {THIS}\n     */\n    withDirection(direction) {\n        (/** @type {?} */ (this))._direction = direction;\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Sets the container that the item is part of.\n     * @param {?} container\n     * @return {?}\n     */\n    _withDropContainer(container) {\n        this._dropContainer = container;\n    }\n    /**\n     * Gets the current position in pixels the draggable outside of a drop container.\n     * @return {?}\n     */\n    getFreeDragPosition() {\n        return { x: this._passiveTransform.x, y: this._passiveTransform.y };\n    }\n    /**\n     * Sets the current position in pixels the draggable outside of a drop container.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} value New position to be set.\n     * @return {THIS}\n     */\n    setFreeDragPosition(value) {\n        (/** @type {?} */ (this))._activeTransform = { x: 0, y: 0 };\n        (/** @type {?} */ (this))._passiveTransform.x = value.x;\n        (/** @type {?} */ (this))._passiveTransform.y = value.y;\n        if (!(/** @type {?} */ (this))._dropContainer) {\n            (/** @type {?} */ (this))._applyRootElementTransform(value.x, value.y);\n        }\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Unsubscribes from the global subscriptions.\n     * @private\n     * @return {?}\n     */\n    _removeSubscriptions() {\n        this._pointerMoveSubscription.unsubscribe();\n        this._pointerUpSubscription.unsubscribe();\n    }\n    /**\n     * Destroys the preview element and its ViewRef.\n     * @private\n     * @return {?}\n     */\n    _destroyPreview() {\n        if (this._preview) {\n            removeElement(this._preview);\n        }\n        if (this._previewRef) {\n            this._previewRef.destroy();\n        }\n        this._preview = this._previewRef = (/** @type {?} */ (null));\n    }\n    /**\n     * Destroys the placeholder element and its ViewRef.\n     * @private\n     * @return {?}\n     */\n    _destroyPlaceholder() {\n        if (this._placeholder) {\n            removeElement(this._placeholder);\n        }\n        if (this._placeholderRef) {\n            this._placeholderRef.destroy();\n        }\n        this._placeholder = this._placeholderRef = (/** @type {?} */ (null));\n    }\n    /**\n     * Starts the dragging sequence.\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    _startDragSequence(event) {\n        // Emit the event on the item before the one on the container.\n        this.started.next({ source: this });\n        if (isTouchEvent(event)) {\n            this._lastTouchEventTime = Date.now();\n        }\n        if (this._dropContainer) {\n            /** @type {?} */\n            const element = this._rootElement;\n            // Grab the `nextSibling` before the preview and placeholder\n            // have been created so we don't get the preview by accident.\n            this._nextSibling = element.nextSibling;\n            /** @type {?} */\n            const preview = this._preview = this._createPreviewElement();\n            /** @type {?} */\n            const placeholder = this._placeholder = this._createPlaceholderElement();\n            // We move the element out at the end of the body and we make it hidden, because keeping it in\n            // place will throw off the consumer's `:last-child` selectors. We can't remove the element\n            // from the DOM completely, because iOS will stop firing all subsequent events in the chain.\n            element.style.display = 'none';\n            this._document.body.appendChild((/** @type {?} */ (element.parentNode)).replaceChild(placeholder, element));\n            getPreviewInsertionPoint(this._document).appendChild(preview);\n            this._dropContainer.start();\n        }\n    }\n    /**\n     * Sets up the different variables and subscriptions\n     * that will be necessary for the dragging sequence.\n     * @private\n     * @param {?} referenceElement Element that started the drag sequence.\n     * @param {?} event Browser event object that started the sequence.\n     * @return {?}\n     */\n    _initializeDragSequence(referenceElement, event) {\n        // Always stop propagation for the event that initializes\n        // the dragging sequence, in order to prevent it from potentially\n        // starting another sequence for a draggable parent somewhere up the DOM tree.\n        event.stopPropagation();\n        /** @type {?} */\n        const isDragging = this.isDragging();\n        /** @type {?} */\n        const isTouchSequence = isTouchEvent(event);\n        /** @type {?} */\n        const isAuxiliaryMouseButton = !isTouchSequence && ((/** @type {?} */ (event))).button !== 0;\n        /** @type {?} */\n        const rootElement = this._rootElement;\n        /** @type {?} */\n        const isSyntheticEvent = !isTouchSequence && this._lastTouchEventTime &&\n            this._lastTouchEventTime + MOUSE_EVENT_IGNORE_TIME > Date.now();\n        // If the event started from an element with the native HTML drag&drop, it'll interfere\n        // with our own dragging (e.g. `img` tags do it by default). Prevent the default action\n        // to stop it from happening. Note that preventing on `dragstart` also seems to work, but\n        // it's flaky and it fails if the user drags it away quickly. Also note that we only want\n        // to do this for `mousedown` since doing the same for `touchstart` will stop any `click`\n        // events from firing on touch devices.\n        if (event.target && ((/** @type {?} */ (event.target))).draggable && event.type === 'mousedown') {\n            event.preventDefault();\n        }\n        // Abort if the user is already dragging or is using a mouse button other than the primary one.\n        if (isDragging || isAuxiliaryMouseButton || isSyntheticEvent) {\n            return;\n        }\n        // If we've got handles, we need to disable the tap highlight on the entire root element,\n        // otherwise iOS will still add it, even though all the drag interactions on the handle\n        // are disabled.\n        if (this._handles.length) {\n            this._rootElementTapHighlight = rootElement.style.webkitTapHighlightColor;\n            rootElement.style.webkitTapHighlightColor = 'transparent';\n        }\n        this._toggleNativeDragInteractions();\n        this._hasStartedDragging = this._hasMoved = false;\n        this._initialContainer = (/** @type {?} */ (this._dropContainer));\n        this._pointerMoveSubscription = this._dragDropRegistry.pointerMove.subscribe(this._pointerMove);\n        this._pointerUpSubscription = this._dragDropRegistry.pointerUp.subscribe(this._pointerUp);\n        this._scrollPosition = this._viewportRuler.getViewportScrollPosition();\n        if (this._boundaryElement) {\n            this._boundaryRect = this._boundaryElement.getBoundingClientRect();\n        }\n        // If we have a custom preview template, the element won't be visible anyway so we avoid the\n        // extra `getBoundingClientRect` calls and just move the preview next to the cursor.\n        this._pickupPositionInElement = this._previewTemplate && this._previewTemplate.template ?\n            { x: 0, y: 0 } :\n            this._getPointerPositionInElement(referenceElement, event);\n        /** @type {?} */\n        const pointerPosition = this._pickupPositionOnPage = this._getPointerPositionOnPage(event);\n        this._pointerDirectionDelta = { x: 0, y: 0 };\n        this._pointerPositionAtLastDirectionChange = { x: pointerPosition.x, y: pointerPosition.y };\n        this._dragStartTime = Date.now();\n        this._dragDropRegistry.startDragging(this, event);\n    }\n    /**\n     * Cleans up the DOM artifacts that were added to facilitate the element being dragged.\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    _cleanupDragArtifacts(event) {\n        // Restore the element's visibility and insert it at its old position in the DOM.\n        // It's important that we maintain the position, because moving the element around in the DOM\n        // can throw off `NgFor` which does smart diffing and re-creates elements only when necessary,\n        // while moving the existing elements in all other cases.\n        this._rootElement.style.display = '';\n        if (this._nextSibling) {\n            (/** @type {?} */ (this._nextSibling.parentNode)).insertBefore(this._rootElement, this._nextSibling);\n        }\n        else {\n            this._initialContainer.element.appendChild(this._rootElement);\n        }\n        this._destroyPreview();\n        this._destroyPlaceholder();\n        this._boundaryRect = this._previewRect = undefined;\n        // Re-enter the NgZone since we bound `document` events on the outside.\n        this._ngZone.run((/**\n         * @return {?}\n         */\n        () => {\n            /** @type {?} */\n            const container = (/** @type {?} */ (this._dropContainer));\n            /** @type {?} */\n            const currentIndex = container.getItemIndex(this);\n            const { x, y } = this._getPointerPositionOnPage(event);\n            /** @type {?} */\n            const isPointerOverContainer = container._isOverContainer(x, y);\n            this.ended.next({ source: this });\n            this.dropped.next({\n                item: this,\n                currentIndex,\n                previousIndex: this._initialContainer.getItemIndex(this),\n                container: container,\n                previousContainer: this._initialContainer,\n                isPointerOverContainer\n            });\n            container.drop(this, currentIndex, this._initialContainer, isPointerOverContainer);\n            this._dropContainer = this._initialContainer;\n        }));\n    }\n    /**\n     * Updates the item's position in its drop container, or moves it\n     * into a new one, depending on its current drag position.\n     * @private\n     * @param {?} __0\n     * @return {?}\n     */\n    _updateActiveDropContainer({ x, y }) {\n        // Drop container that draggable has been moved into.\n        /** @type {?} */\n        let newContainer = (/** @type {?} */ (this._dropContainer))._getSiblingContainerFromPosition(this, x, y) ||\n            this._initialContainer._getSiblingContainerFromPosition(this, x, y);\n        // If we couldn't find a new container to move the item into, and the item has left it's\n        // initial container, check whether the it's over the initial container. This handles the\n        // case where two containers are connected one way and the user tries to undo dragging an\n        // item into a new container.\n        if (!newContainer && this._dropContainer !== this._initialContainer &&\n            this._initialContainer._isOverContainer(x, y)) {\n            newContainer = this._initialContainer;\n        }\n        if (newContainer && newContainer !== this._dropContainer) {\n            this._ngZone.run((/**\n             * @return {?}\n             */\n            () => {\n                // Notify the old container that the item has left.\n                this.exited.next({ item: this, container: (/** @type {?} */ (this._dropContainer)) });\n                (/** @type {?} */ (this._dropContainer)).exit(this);\n                // Notify the new container that the item has entered.\n                this.entered.next({ item: this, container: (/** @type {?} */ (newContainer)) });\n                this._dropContainer = (/** @type {?} */ (newContainer));\n                this._dropContainer.enter(this, x, y);\n            }));\n        }\n        (/** @type {?} */ (this._dropContainer))._sortItem(this, x, y, this._pointerDirectionDelta);\n        this._preview.style.transform =\n            getTransform(x - this._pickupPositionInElement.x, y - this._pickupPositionInElement.y);\n    }\n    /**\n     * Creates the element that will be rendered next to the user's pointer\n     * and will be used as a preview of the element that is being dragged.\n     * @private\n     * @return {?}\n     */\n    _createPreviewElement() {\n        /** @type {?} */\n        const previewConfig = this._previewTemplate;\n        /** @type {?} */\n        const previewTemplate = previewConfig ? previewConfig.template : null;\n        /** @type {?} */\n        let preview;\n        if (previewTemplate) {\n            /** @type {?} */\n            const viewRef = (/** @type {?} */ (previewConfig)).viewContainer.createEmbeddedView(previewTemplate, (/** @type {?} */ (previewConfig)).context);\n            preview = viewRef.rootNodes[0];\n            this._previewRef = viewRef;\n            preview.style.transform =\n                getTransform(this._pickupPositionOnPage.x, this._pickupPositionOnPage.y);\n        }\n        else {\n            /** @type {?} */\n            const element = this._rootElement;\n            /** @type {?} */\n            const elementRect = element.getBoundingClientRect();\n            preview = deepCloneNode(element);\n            preview.style.width = `${elementRect.width}px`;\n            preview.style.height = `${elementRect.height}px`;\n            preview.style.transform = getTransform(elementRect.left, elementRect.top);\n        }\n        extendStyles(preview.style, {\n            // It's important that we disable the pointer events on the preview, because\n            // it can throw off the `document.elementFromPoint` calls in the `CdkDropList`.\n            pointerEvents: 'none',\n            position: 'fixed',\n            top: '0',\n            left: '0',\n            zIndex: '1000'\n        });\n        toggleNativeDragInteractions(preview, false);\n        preview.classList.add('cdk-drag-preview');\n        preview.setAttribute('dir', this._direction);\n        return preview;\n    }\n    /**\n     * Animates the preview element from its current position to the location of the drop placeholder.\n     * @private\n     * @return {?} Promise that resolves when the animation completes.\n     */\n    _animatePreviewToPlaceholder() {\n        // If the user hasn't moved yet, the transitionend event won't fire.\n        if (!this._hasMoved) {\n            return Promise.resolve();\n        }\n        /** @type {?} */\n        const placeholderRect = this._placeholder.getBoundingClientRect();\n        // Apply the class that adds a transition to the preview.\n        this._preview.classList.add('cdk-drag-animating');\n        // Move the preview to the placeholder position.\n        this._preview.style.transform = getTransform(placeholderRect.left, placeholderRect.top);\n        // If the element doesn't have a `transition`, the `transitionend` event won't fire. Since\n        // we need to trigger a style recalculation in order for the `cdk-drag-animating` class to\n        // apply its style, we take advantage of the available info to figure out whether we need to\n        // bind the event in the first place.\n        /** @type {?} */\n        const duration = getTransformTransitionDurationInMs(this._preview);\n        if (duration === 0) {\n            return Promise.resolve();\n        }\n        return this._ngZone.runOutsideAngular((/**\n         * @return {?}\n         */\n        () => {\n            return new Promise((/**\n             * @param {?} resolve\n             * @return {?}\n             */\n            resolve => {\n                /** @type {?} */\n                const handler = (/** @type {?} */ (((/**\n                 * @param {?} event\n                 * @return {?}\n                 */\n                (event) => {\n                    if (!event || (event.target === this._preview && event.propertyName === 'transform')) {\n                        this._preview.removeEventListener('transitionend', handler);\n                        resolve();\n                        clearTimeout(timeout);\n                    }\n                }))));\n                // If a transition is short enough, the browser might not fire the `transitionend` event.\n                // Since we know how long it's supposed to take, add a timeout with a 50% buffer that'll\n                // fire if the transition hasn't completed when it was supposed to.\n                /** @type {?} */\n                const timeout = setTimeout((/** @type {?} */ (handler)), duration * 1.5);\n                this._preview.addEventListener('transitionend', handler);\n            }));\n        }));\n    }\n    /**\n     * Creates an element that will be shown instead of the current element while dragging.\n     * @private\n     * @return {?}\n     */\n    _createPlaceholderElement() {\n        /** @type {?} */\n        const placeholderConfig = this._placeholderTemplate;\n        /** @type {?} */\n        const placeholderTemplate = placeholderConfig ? placeholderConfig.template : null;\n        /** @type {?} */\n        let placeholder;\n        if (placeholderTemplate) {\n            this._placeholderRef = (/** @type {?} */ (placeholderConfig)).viewContainer.createEmbeddedView(placeholderTemplate, (/** @type {?} */ (placeholderConfig)).context);\n            placeholder = this._placeholderRef.rootNodes[0];\n        }\n        else {\n            placeholder = deepCloneNode(this._rootElement);\n        }\n        placeholder.classList.add('cdk-drag-placeholder');\n        return placeholder;\n    }\n    /**\n     * Figures out the coordinates at which an element was picked up.\n     * @private\n     * @param {?} referenceElement Element that initiated the dragging.\n     * @param {?} event Event that initiated the dragging.\n     * @return {?}\n     */\n    _getPointerPositionInElement(referenceElement, event) {\n        /** @type {?} */\n        const elementRect = this._rootElement.getBoundingClientRect();\n        /** @type {?} */\n        const handleElement = referenceElement === this._rootElement ? null : referenceElement;\n        /** @type {?} */\n        const referenceRect = handleElement ? handleElement.getBoundingClientRect() : elementRect;\n        /** @type {?} */\n        const point = isTouchEvent(event) ? event.targetTouches[0] : event;\n        /** @type {?} */\n        const x = point.pageX - referenceRect.left - this._scrollPosition.left;\n        /** @type {?} */\n        const y = point.pageY - referenceRect.top - this._scrollPosition.top;\n        return {\n            x: referenceRect.left - elementRect.left + x,\n            y: referenceRect.top - elementRect.top + y\n        };\n    }\n    /**\n     * Determines the point of the page that was touched by the user.\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    _getPointerPositionOnPage(event) {\n        // `touches` will be empty for start/end events so we have to fall back to `changedTouches`.\n        /** @type {?} */\n        const point = isTouchEvent(event) ? (event.touches[0] || event.changedTouches[0]) : event;\n        return {\n            x: point.pageX - this._scrollPosition.left,\n            y: point.pageY - this._scrollPosition.top\n        };\n    }\n    /**\n     * Gets the pointer position on the page, accounting for any position constraints.\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    _getConstrainedPointerPosition(event) {\n        /** @type {?} */\n        const point = this._getPointerPositionOnPage(event);\n        /** @type {?} */\n        const constrainedPoint = this.constrainPosition ? this.constrainPosition(point) : point;\n        /** @type {?} */\n        const dropContainerLock = this._dropContainer ? this._dropContainer.lockAxis : null;\n        if (this.lockAxis === 'x' || dropContainerLock === 'x') {\n            constrainedPoint.y = this._pickupPositionOnPage.y;\n        }\n        else if (this.lockAxis === 'y' || dropContainerLock === 'y') {\n            constrainedPoint.x = this._pickupPositionOnPage.x;\n        }\n        if (this._boundaryRect) {\n            const { x: pickupX, y: pickupY } = this._pickupPositionInElement;\n            /** @type {?} */\n            const boundaryRect = this._boundaryRect;\n            /** @type {?} */\n            const previewRect = (/** @type {?} */ (this._previewRect));\n            /** @type {?} */\n            const minY = boundaryRect.top + pickupY;\n            /** @type {?} */\n            const maxY = boundaryRect.bottom - (previewRect.height - pickupY);\n            /** @type {?} */\n            const minX = boundaryRect.left + pickupX;\n            /** @type {?} */\n            const maxX = boundaryRect.right - (previewRect.width - pickupX);\n            constrainedPoint.x = clamp(constrainedPoint.x, minX, maxX);\n            constrainedPoint.y = clamp(constrainedPoint.y, minY, maxY);\n        }\n        return constrainedPoint;\n    }\n    /**\n     * Updates the current drag delta, based on the user's current pointer position on the page.\n     * @private\n     * @param {?} pointerPositionOnPage\n     * @return {?}\n     */\n    _updatePointerDirectionDelta(pointerPositionOnPage) {\n        const { x, y } = pointerPositionOnPage;\n        /** @type {?} */\n        const delta = this._pointerDirectionDelta;\n        /** @type {?} */\n        const positionSinceLastChange = this._pointerPositionAtLastDirectionChange;\n        // Amount of pixels the user has dragged since the last time the direction changed.\n        /** @type {?} */\n        const changeX = Math.abs(x - positionSinceLastChange.x);\n        /** @type {?} */\n        const changeY = Math.abs(y - positionSinceLastChange.y);\n        // Because we handle pointer events on a per-pixel basis, we don't want the delta\n        // to change for every pixel, otherwise anything that depends on it can look erratic.\n        // To make the delta more consistent, we track how much the user has moved since the last\n        // delta change and we only update it after it has reached a certain threshold.\n        if (changeX > this._config.pointerDirectionChangeThreshold) {\n            delta.x = x > positionSinceLastChange.x ? 1 : -1;\n            positionSinceLastChange.x = x;\n        }\n        if (changeY > this._config.pointerDirectionChangeThreshold) {\n            delta.y = y > positionSinceLastChange.y ? 1 : -1;\n            positionSinceLastChange.y = y;\n        }\n        return delta;\n    }\n    /**\n     * Toggles the native drag interactions, based on how many handles are registered.\n     * @private\n     * @return {?}\n     */\n    _toggleNativeDragInteractions() {\n        if (!this._rootElement || !this._handles) {\n            return;\n        }\n        /** @type {?} */\n        const shouldEnable = this.disabled || this._handles.length > 0;\n        if (shouldEnable !== this._nativeInteractionsEnabled) {\n            this._nativeInteractionsEnabled = shouldEnable;\n            toggleNativeDragInteractions(this._rootElement, shouldEnable);\n        }\n    }\n    /**\n     * Removes the manually-added event listeners from the root element.\n     * @private\n     * @param {?} element\n     * @return {?}\n     */\n    _removeRootElementListeners(element) {\n        element.removeEventListener('mousedown', this._pointerDown, activeEventListenerOptions);\n        element.removeEventListener('touchstart', this._pointerDown, passiveEventListenerOptions);\n    }\n    /**\n     * Applies a `transform` to the root element, taking into account any existing transforms on it.\n     * @private\n     * @param {?} x New transform value along the X axis.\n     * @param {?} y New transform value along the Y axis.\n     * @return {?}\n     */\n    _applyRootElementTransform(x, y) {\n        /** @type {?} */\n        const transform = getTransform(x, y);\n        // Cache the previous transform amount only after the first drag sequence, because\n        // we don't want our own transforms to stack on top of each other.\n        if (this._initialTransform == null) {\n            this._initialTransform = this._rootElement.style.transform || '';\n        }\n        // Preserve the previous `transform` value, if there was one. Note that we apply our own\n        // transform before the user's, because things like rotation can affect which direction\n        // the element will be translated towards.\n        this._rootElement.style.transform = this._initialTransform ?\n            transform + ' ' + this._initialTransform : transform;\n    }\n}\n/**\n * Gets a 3d `transform` that can be applied to an element.\n * @param {?} x Desired position of the element along the X axis.\n * @param {?} y Desired position of the element along the Y axis.\n * @return {?}\n */\nfunction getTransform(x, y) {\n    // Round the transforms since some browsers will\n    // blur the elements for sub-pixel transforms.\n    return `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`;\n}\n/**\n * Creates a deep clone of an element.\n * @param {?} node\n * @return {?}\n */\nfunction deepCloneNode(node) {\n    /** @type {?} */\n    const clone = (/** @type {?} */ (node.cloneNode(true)));\n    /** @type {?} */\n    const descendantsWithId = clone.querySelectorAll('[id]');\n    // Remove the `id` to avoid having multiple elements with the same id on the page.\n    clone.removeAttribute('id');\n    for (let i = 0; i < descendantsWithId.length; i++) {\n        descendantsWithId[i].removeAttribute('id');\n    }\n    return clone;\n}\n/**\n * Clamps a value between a minimum and a maximum.\n * @param {?} value\n * @param {?} min\n * @param {?} max\n * @return {?}\n */\nfunction clamp(value, min, max) {\n    return Math.max(min, Math.min(max, value));\n}\n/**\n * Helper to remove an element from the DOM and to do all the necessary null checks.\n * @param {?} element Element to be removed.\n * @return {?}\n */\nfunction removeElement(element) {\n    if (element && element.parentNode) {\n        element.parentNode.removeChild(element);\n    }\n}\n/**\n * Determines whether an event is a touch event.\n * @param {?} event\n * @return {?}\n */\nfunction isTouchEvent(event) {\n    return event.type.startsWith('touch');\n}\n/**\n * Gets the element into which the drag preview should be inserted.\n * @param {?} documentRef\n * @return {?}\n */\nfunction getPreviewInsertionPoint(documentRef) {\n    // We can't use the body if the user is in fullscreen mode,\n    // because the preview will render under the fullscreen element.\n    // TODO(crisbeto): dedupe this with the `FullscreenOverlayContainer` eventually.\n    return documentRef.fullscreenElement ||\n        documentRef.webkitFullscreenElement ||\n        documentRef.mozFullScreenElement ||\n        documentRef.msFullscreenElement ||\n        documentRef.body;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Moves an item one index in an array to another.\n * @template T\n * @param {?} array Array in which to move the item.\n * @param {?} fromIndex Starting index of the item.\n * @param {?} toIndex Index to which the item should be moved.\n * @return {?}\n */\nfunction moveItemInArray(array, fromIndex, toIndex) {\n    /** @type {?} */\n    const from = clamp$1(fromIndex, array.length - 1);\n    /** @type {?} */\n    const to = clamp$1(toIndex, array.length - 1);\n    if (from === to) {\n        return;\n    }\n    /** @type {?} */\n    const target = array[from];\n    /** @type {?} */\n    const delta = to < from ? -1 : 1;\n    for (let i = from; i !== to; i += delta) {\n        array[i] = array[i + delta];\n    }\n    array[to] = target;\n}\n/**\n * Moves an item from one array to another.\n * @template T\n * @param {?} currentArray Array from which to transfer the item.\n * @param {?} targetArray Array into which to put the item.\n * @param {?} currentIndex Index of the item in its current array.\n * @param {?} targetIndex Index at which to insert the item.\n * @return {?}\n */\nfunction transferArrayItem(currentArray, targetArray, currentIndex, targetIndex) {\n    /** @type {?} */\n    const from = clamp$1(currentIndex, currentArray.length - 1);\n    /** @type {?} */\n    const to = clamp$1(targetIndex, targetArray.length);\n    if (currentArray.length) {\n        targetArray.splice(to, 0, currentArray.splice(from, 1)[0]);\n    }\n}\n/**\n * Copies an item from one array to another, leaving it in its\n * original position in current array.\n * @template T\n * @param {?} currentArray Array from which to copy the item.\n * @param {?} targetArray Array into which is copy the item.\n * @param {?} currentIndex Index of the item in its current array.\n * @param {?} targetIndex Index at which to insert the item.\n *\n * @return {?}\n */\nfunction copyArrayItem(currentArray, targetArray, currentIndex, targetIndex) {\n    /** @type {?} */\n    const to = clamp$1(targetIndex, targetArray.length);\n    if (currentArray.length) {\n        targetArray.splice(to, 0, currentArray[currentIndex]);\n    }\n}\n/**\n * Clamps a number between zero and a maximum.\n * @param {?} value\n * @param {?} max\n * @return {?}\n */\nfunction clamp$1(value, max) {\n    return Math.max(0, Math.min(max, value));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Counter used to generate unique ids for drop refs.\n * @type {?}\n */\nlet _uniqueIdCounter = 0;\n/**\n * Proximity, as a ratio to width/height, at which a\n * dragged item will affect the drop container.\n * @type {?}\n */\nconst DROP_PROXIMITY_THRESHOLD = 0.05;\n/**\n * Reference to a drop list. Used to manipulate or dispose of the container.\n * \\@docs-private\n * @template T\n */\nclass DropListRef {\n    /**\n     * @param {?} element\n     * @param {?} _dragDropRegistry\n     * @param {?} _document\n     */\n    constructor(element, _dragDropRegistry, _document) {\n        this._dragDropRegistry = _dragDropRegistry;\n        /**\n         * Unique ID for the drop list.\n         * @deprecated No longer being used. To be removed.\n         * \\@breaking-change 8.0.0\n         */\n        this.id = `cdk-drop-list-ref-${_uniqueIdCounter++}`;\n        /**\n         * Whether starting a dragging sequence from this container is disabled.\n         */\n        this.disabled = false;\n        /**\n         * Whether sorting items within the list is disabled.\n         */\n        this.sortingDisabled = true;\n        /**\n         * Function that is used to determine whether an item\n         * is allowed to be moved into a drop container.\n         */\n        this.enterPredicate = (/**\n         * @return {?}\n         */\n        () => true);\n        /**\n         * Emits right before dragging has started.\n         */\n        this.beforeStarted = new Subject();\n        /**\n         * Emits when the user has moved a new drag item into this container.\n         */\n        this.entered = new Subject();\n        /**\n         * Emits when the user removes an item from the container\n         * by dragging it into another container.\n         */\n        this.exited = new Subject();\n        /**\n         * Emits when the user drops an item inside the container.\n         */\n        this.dropped = new Subject();\n        /**\n         * Emits as the user is swapping items while actively dragging.\n         */\n        this.sorted = new Subject();\n        /**\n         * Whether an item in the list is being dragged.\n         */\n        this._isDragging = false;\n        /**\n         * Cache of the dimensions of all the items inside the container.\n         */\n        this._itemPositions = [];\n        /**\n         * Keeps track of the item that was last swapped with the dragged item, as\n         * well as what direction the pointer was moving in when the swap occured.\n         */\n        this._previousSwap = { drag: (/** @type {?} */ (null)), delta: 0 };\n        /**\n         * Drop lists that are connected to the current one.\n         */\n        this._siblings = [];\n        /**\n         * Direction in which the list is oriented.\n         */\n        this._orientation = 'vertical';\n        /**\n         * Connected siblings that currently have a dragged item.\n         */\n        this._activeSiblings = new Set();\n        /**\n         * Layout direction of the drop list.\n         */\n        this._direction = 'ltr';\n        _dragDropRegistry.registerDropContainer(this);\n        this._document = _document;\n        this.element = element instanceof ElementRef ? element.nativeElement : element;\n    }\n    /**\n     * Removes the drop list functionality from the DOM element.\n     * @return {?}\n     */\n    dispose() {\n        this.beforeStarted.complete();\n        this.entered.complete();\n        this.exited.complete();\n        this.dropped.complete();\n        this.sorted.complete();\n        this._activeSiblings.clear();\n        this._dragDropRegistry.removeDropContainer(this);\n    }\n    /**\n     * Whether an item from this list is currently being dragged.\n     * @return {?}\n     */\n    isDragging() {\n        return this._isDragging;\n    }\n    /**\n     * Starts dragging an item.\n     * @return {?}\n     */\n    start() {\n        this.beforeStarted.next();\n        this._isDragging = true;\n        this._activeDraggables = this._draggables.slice();\n        this._cacheOwnPosition();\n        this._cacheItemPositions();\n        this._siblings.forEach((/**\n         * @param {?} sibling\n         * @return {?}\n         */\n        sibling => sibling._startReceiving(this)));\n    }\n    /**\n     * Emits an event to indicate that the user moved an item into the container.\n     * @param {?} item Item that was moved into the container.\n     * @param {?} pointerX Position of the item along the X axis.\n     * @param {?} pointerY Position of the item along the Y axis.\n     * @return {?}\n     */\n    enter(item, pointerX, pointerY) {\n        this.entered.next({ item, container: this });\n        this.start();\n        // If sorting is disabled, we want the item to return to its starting\n        // position if the user is returning it to its initial container.\n        /** @type {?} */\n        let newIndex = this.sortingDisabled ? this._draggables.indexOf(item) : -1;\n        if (newIndex === -1) {\n            // We use the coordinates of where the item entered the drop\n            // zone to figure out at which index it should be inserted.\n            newIndex = this._getItemIndexFromPointerPosition(item, pointerX, pointerY);\n        }\n        /** @type {?} */\n        const activeDraggables = this._activeDraggables;\n        /** @type {?} */\n        const currentIndex = activeDraggables.indexOf(item);\n        /** @type {?} */\n        const placeholder = item.getPlaceholderElement();\n        /** @type {?} */\n        let newPositionReference = activeDraggables[newIndex];\n        // If the item at the new position is the same as the item that is being dragged,\n        // it means that we're trying to restore the item to its initial position. In this\n        // case we should use the next item from the list as the reference.\n        if (newPositionReference === item) {\n            newPositionReference = activeDraggables[newIndex + 1];\n        }\n        // Since the item may be in the `activeDraggables` already (e.g. if the user dragged it\n        // into another container and back again), we have to ensure that it isn't duplicated.\n        if (currentIndex > -1) {\n            activeDraggables.splice(currentIndex, 1);\n        }\n        // Don't use items that are being dragged as a reference, because\n        // their element has been moved down to the bottom of the body.\n        if (newPositionReference && !this._dragDropRegistry.isDragging(newPositionReference)) {\n            /** @type {?} */\n            const element = newPositionReference.getRootElement();\n            (/** @type {?} */ (element.parentElement)).insertBefore(placeholder, element);\n            activeDraggables.splice(newIndex, 0, item);\n        }\n        else {\n            this.element.appendChild(placeholder);\n            activeDraggables.push(item);\n        }\n        // The transform needs to be cleared so it doesn't throw off the measurements.\n        placeholder.style.transform = '';\n        // Note that the positions were already cached when we called `start` above,\n        // but we need to refresh them since the amount of items has changed.\n        this._cacheItemPositions();\n    }\n    /**\n     * Removes an item from the container after it was dragged into another container by the user.\n     * @param {?} item Item that was dragged out.\n     * @return {?}\n     */\n    exit(item) {\n        this._reset();\n        this.exited.next({ item, container: this });\n    }\n    /**\n     * Drops an item into this container.\n     * @param {?} item Item being dropped into the container.\n     * @param {?} currentIndex Index at which the item should be inserted.\n     * @param {?} previousContainer Container from which the item got dragged in.\n     * @param {?} isPointerOverContainer Whether the user's pointer was over the\n     *    container when the item was dropped.\n     * @return {?}\n     */\n    drop(item, currentIndex, previousContainer, isPointerOverContainer) {\n        this._reset();\n        this.dropped.next({\n            item,\n            currentIndex,\n            previousIndex: previousContainer.getItemIndex(item),\n            container: this,\n            previousContainer,\n            isPointerOverContainer\n        });\n    }\n    /**\n     * Sets the draggable items that are a part of this list.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} items Items that are a part of this list.\n     * @return {THIS}\n     */\n    withItems(items) {\n        (/** @type {?} */ (this))._draggables = items;\n        items.forEach((/**\n         * @param {?} item\n         * @return {?}\n         */\n        item => item._withDropContainer((/** @type {?} */ (this)))));\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Sets the layout direction of the drop list.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} direction\n     * @return {THIS}\n     */\n    withDirection(direction) {\n        (/** @type {?} */ (this))._direction = direction;\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Sets the containers that are connected to this one. When two or more containers are\n     * connected, the user will be allowed to transfer items between them.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} connectedTo Other containers that the current containers should be connected to.\n     * @return {THIS}\n     */\n    connectedTo(connectedTo) {\n        (/** @type {?} */ (this))._siblings = connectedTo.slice();\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Sets the orientation of the container.\n     * @template THIS\n     * @this {THIS}\n     * @param {?} orientation New orientation for the container.\n     * @return {THIS}\n     */\n    withOrientation(orientation) {\n        (/** @type {?} */ (this))._orientation = orientation;\n        return (/** @type {?} */ (this));\n    }\n    /**\n     * Figures out the index of an item in the container.\n     * @param {?} item Item whose index should be determined.\n     * @return {?}\n     */\n    getItemIndex(item) {\n        if (!this._isDragging) {\n            return this._draggables.indexOf(item);\n        }\n        // Items are sorted always by top/left in the cache, however they flow differently in RTL.\n        // The rest of the logic still stands no matter what orientation we're in, however\n        // we need to invert the array when determining the index.\n        /** @type {?} */\n        const items = this._orientation === 'horizontal' && this._direction === 'rtl' ?\n            this._itemPositions.slice().reverse() : this._itemPositions;\n        return findIndex(items, (/**\n         * @param {?} currentItem\n         * @return {?}\n         */\n        currentItem => currentItem.drag === item));\n    }\n    /**\n     * Whether the list is able to receive the item that\n     * is currently being dragged inside a connected drop list.\n     * @return {?}\n     */\n    isReceiving() {\n        return this._activeSiblings.size > 0;\n    }\n    /**\n     * Sorts an item inside the container based on its position.\n     * @param {?} item Item to be sorted.\n     * @param {?} pointerX Position of the item along the X axis.\n     * @param {?} pointerY Position of the item along the Y axis.\n     * @param {?} pointerDelta Direction in which the pointer is moving along each axis.\n     * @return {?}\n     */\n    _sortItem(item, pointerX, pointerY, pointerDelta) {\n        // Don't sort the item if sorting is disabled or it's out of range.\n        if (this.sortingDisabled || !this._isPointerNearDropContainer(pointerX, pointerY)) {\n            return;\n        }\n        /** @type {?} */\n        const siblings = this._itemPositions;\n        /** @type {?} */\n        const newIndex = this._getItemIndexFromPointerPosition(item, pointerX, pointerY, pointerDelta);\n        if (newIndex === -1 && siblings.length > 0) {\n            return;\n        }\n        /** @type {?} */\n        const isHorizontal = this._orientation === 'horizontal';\n        /** @type {?} */\n        const currentIndex = findIndex(siblings, (/**\n         * @param {?} currentItem\n         * @return {?}\n         */\n        currentItem => currentItem.drag === item));\n        /** @type {?} */\n        const siblingAtNewPosition = siblings[newIndex];\n        /** @type {?} */\n        const currentPosition = siblings[currentIndex].clientRect;\n        /** @type {?} */\n        const newPosition = siblingAtNewPosition.clientRect;\n        /** @type {?} */\n        const delta = currentIndex > newIndex ? 1 : -1;\n        this._previousSwap.drag = siblingAtNewPosition.drag;\n        this._previousSwap.delta = isHorizontal ? pointerDelta.x : pointerDelta.y;\n        // How many pixels the item's placeholder should be offset.\n        /** @type {?} */\n        const itemOffset = this._getItemOffsetPx(currentPosition, newPosition, delta);\n        // How many pixels all the other items should be offset.\n        /** @type {?} */\n        const siblingOffset = this._getSiblingOffsetPx(currentIndex, siblings, delta);\n        // Save the previous order of the items before moving the item to its new index.\n        // We use this to check whether an item has been moved as a result of the sorting.\n        /** @type {?} */\n        const oldOrder = siblings.slice();\n        // Shuffle the array in place.\n        moveItemInArray(siblings, currentIndex, newIndex);\n        this.sorted.next({\n            previousIndex: currentIndex,\n            currentIndex: newIndex,\n            container: this,\n            item\n        });\n        siblings.forEach((/**\n         * @param {?} sibling\n         * @param {?} index\n         * @return {?}\n         */\n        (sibling, index) => {\n            // Don't do anything if the position hasn't changed.\n            if (oldOrder[index] === sibling) {\n                return;\n            }\n            /** @type {?} */\n            const isDraggedItem = sibling.drag === item;\n            /** @type {?} */\n            const offset = isDraggedItem ? itemOffset : siblingOffset;\n            /** @type {?} */\n            const elementToOffset = isDraggedItem ? item.getPlaceholderElement() :\n                sibling.drag.getRootElement();\n            // Update the offset to reflect the new position.\n            sibling.offset += offset;\n            // Since we're moving the items with a `transform`, we need to adjust their cached\n            // client rects to reflect their new position, as well as swap their positions in the cache.\n            // Note that we shouldn't use `getBoundingClientRect` here to update the cache, because the\n            // elements may be mid-animation which will give us a wrong result.\n            if (isHorizontal) {\n                // Round the transforms since some browsers will\n                // blur the elements, for sub-pixel transforms.\n                elementToOffset.style.transform = `translate3d(${Math.round(sibling.offset)}px, 0, 0)`;\n                adjustClientRect(sibling.clientRect, 0, offset);\n            }\n            else {\n                elementToOffset.style.transform = `translate3d(0, ${Math.round(sibling.offset)}px, 0)`;\n                adjustClientRect(sibling.clientRect, offset, 0);\n            }\n        }));\n    }\n    /**\n     * Caches the position of the drop list.\n     * @private\n     * @return {?}\n     */\n    _cacheOwnPosition() {\n        this._clientRect = this.element.getBoundingClientRect();\n    }\n    /**\n     * Refreshes the position cache of the items and sibling containers.\n     * @private\n     * @return {?}\n     */\n    _cacheItemPositions() {\n        /** @type {?} */\n        const isHorizontal = this._orientation === 'horizontal';\n        this._itemPositions = this._activeDraggables.map((/**\n         * @param {?} drag\n         * @return {?}\n         */\n        drag => {\n            /** @type {?} */\n            const elementToMeasure = this._dragDropRegistry.isDragging(drag) ?\n                // If the element is being dragged, we have to measure the\n                // placeholder, because the element is hidden.\n                drag.getPlaceholderElement() :\n                drag.getRootElement();\n            /** @type {?} */\n            const clientRect = elementToMeasure.getBoundingClientRect();\n            return {\n                drag,\n                offset: 0,\n                // We need to clone the `clientRect` here, because all the values on it are readonly\n                // and we need to be able to update them. Also we can't use a spread here, because\n                // the values on a `ClientRect` aren't own properties. See:\n                // https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect#Notes\n                clientRect: {\n                    top: clientRect.top,\n                    right: clientRect.right,\n                    bottom: clientRect.bottom,\n                    left: clientRect.left,\n                    width: clientRect.width,\n                    height: clientRect.height\n                }\n            };\n        })).sort((/**\n         * @param {?} a\n         * @param {?} b\n         * @return {?}\n         */\n        (a, b) => {\n            return isHorizontal ? a.clientRect.left - b.clientRect.left :\n                a.clientRect.top - b.clientRect.top;\n        }));\n    }\n    /**\n     * Resets the container to its initial state.\n     * @private\n     * @return {?}\n     */\n    _reset() {\n        this._isDragging = false;\n        // TODO(crisbeto): may have to wait for the animations to finish.\n        this._activeDraggables.forEach((/**\n         * @param {?} item\n         * @return {?}\n         */\n        item => item.getRootElement().style.transform = ''));\n        this._siblings.forEach((/**\n         * @param {?} sibling\n         * @return {?}\n         */\n        sibling => sibling._stopReceiving(this)));\n        this._activeDraggables = [];\n        this._itemPositions = [];\n        this._previousSwap.drag = null;\n        this._previousSwap.delta = 0;\n    }\n    /**\n     * Gets the offset in pixels by which the items that aren't being dragged should be moved.\n     * @private\n     * @param {?} currentIndex Index of the item currently being dragged.\n     * @param {?} siblings All of the items in the list.\n     * @param {?} delta Direction in which the user is moving.\n     * @return {?}\n     */\n    _getSiblingOffsetPx(currentIndex, siblings, delta) {\n        /** @type {?} */\n        const isHorizontal = this._orientation === 'horizontal';\n        /** @type {?} */\n        const currentPosition = siblings[currentIndex].clientRect;\n        /** @type {?} */\n        const immediateSibling = siblings[currentIndex + delta * -1];\n        /** @type {?} */\n        let siblingOffset = currentPosition[isHorizontal ? 'width' : 'height'] * delta;\n        if (immediateSibling) {\n            /** @type {?} */\n            const start = isHorizontal ? 'left' : 'top';\n            /** @type {?} */\n            const end = isHorizontal ? 'right' : 'bottom';\n            // Get the spacing between the start of the current item and the end of the one immediately\n            // after it in the direction in which the user is dragging, or vice versa. We add it to the\n            // offset in order to push the element to where it will be when it's inline and is influenced\n            // by the `margin` of its siblings.\n            if (delta === -1) {\n                siblingOffset -= immediateSibling.clientRect[start] - currentPosition[end];\n            }\n            else {\n                siblingOffset += currentPosition[start] - immediateSibling.clientRect[end];\n            }\n        }\n        return siblingOffset;\n    }\n    /**\n     * Checks whether the pointer coordinates are close to the drop container.\n     * @private\n     * @param {?} pointerX Coordinates along the X axis.\n     * @param {?} pointerY Coordinates along the Y axis.\n     * @return {?}\n     */\n    _isPointerNearDropContainer(pointerX, pointerY) {\n        const { top, right, bottom, left, width, height } = this._clientRect;\n        /** @type {?} */\n        const xThreshold = width * DROP_PROXIMITY_THRESHOLD;\n        /** @type {?} */\n        const yThreshold = height * DROP_PROXIMITY_THRESHOLD;\n        return pointerY > top - yThreshold && pointerY < bottom + yThreshold &&\n            pointerX > left - xThreshold && pointerX < right + xThreshold;\n    }\n    /**\n     * Gets the offset in pixels by which the item that is being dragged should be moved.\n     * @private\n     * @param {?} currentPosition Current position of the item.\n     * @param {?} newPosition Position of the item where the current item should be moved.\n     * @param {?} delta Direction in which the user is moving.\n     * @return {?}\n     */\n    _getItemOffsetPx(currentPosition, newPosition, delta) {\n        /** @type {?} */\n        const isHorizontal = this._orientation === 'horizontal';\n        /** @type {?} */\n        let itemOffset = isHorizontal ? newPosition.left - currentPosition.left :\n            newPosition.top - currentPosition.top;\n        // Account for differences in the item width/height.\n        if (delta === -1) {\n            itemOffset += isHorizontal ? newPosition.width - currentPosition.width :\n                newPosition.height - currentPosition.height;\n        }\n        return itemOffset;\n    }\n    /**\n     * Gets the index of an item in the drop container, based on the position of the user's pointer.\n     * @private\n     * @param {?} item Item that is being sorted.\n     * @param {?} pointerX Position of the user's pointer along the X axis.\n     * @param {?} pointerY Position of the user's pointer along the Y axis.\n     * @param {?=} delta Direction in which the user is moving their pointer.\n     * @return {?}\n     */\n    _getItemIndexFromPointerPosition(item, pointerX, pointerY, delta) {\n        /** @type {?} */\n        const isHorizontal = this._orientation === 'horizontal';\n        return findIndex(this._itemPositions, (/**\n         * @param {?} __0\n         * @param {?} _\n         * @param {?} array\n         * @return {?}\n         */\n        ({ drag, clientRect }, _, array) => {\n            if (drag === item) {\n                // If there's only one item left in the container, it must be\n                // the dragged item itself so we use it as a reference.\n                return array.length < 2;\n            }\n            if (delta) {\n                /** @type {?} */\n                const direction = isHorizontal ? delta.x : delta.y;\n                // If the user is still hovering over the same item as last time, and they didn't change\n                // the direction in which they're dragging, we don't consider it a direction swap.\n                if (drag === this._previousSwap.drag && direction === this._previousSwap.delta) {\n                    return false;\n                }\n            }\n            return isHorizontal ?\n                // Round these down since most browsers report client rects with\n                // sub-pixel precision, whereas the pointer coordinates are rounded to pixels.\n                pointerX >= Math.floor(clientRect.left) && pointerX <= Math.floor(clientRect.right) :\n                pointerY >= Math.floor(clientRect.top) && pointerY <= Math.floor(clientRect.bottom);\n        }));\n    }\n    /**\n     * Checks whether the user's pointer is positioned over the container.\n     * @param {?} x Pointer position along the X axis.\n     * @param {?} y Pointer position along the Y axis.\n     * @return {?}\n     */\n    _isOverContainer(x, y) {\n        return isInsideClientRect(this._clientRect, x, y);\n    }\n    /**\n     * Figures out whether an item should be moved into a sibling\n     * drop container, based on its current position.\n     * @param {?} item Drag item that is being moved.\n     * @param {?} x Position of the item along the X axis.\n     * @param {?} y Position of the item along the Y axis.\n     * @return {?}\n     */\n    _getSiblingContainerFromPosition(item, x, y) {\n        return this._siblings.find((/**\n         * @param {?} sibling\n         * @return {?}\n         */\n        sibling => sibling._canReceive(item, x, y)));\n    }\n    /**\n     * Checks whether the drop list can receive the passed-in item.\n     * @param {?} item Item that is being dragged into the list.\n     * @param {?} x Position of the item along the X axis.\n     * @param {?} y Position of the item along the Y axis.\n     * @return {?}\n     */\n    _canReceive(item, x, y) {\n        if (!this.enterPredicate(item, this) || !isInsideClientRect(this._clientRect, x, y)) {\n            return false;\n        }\n        /** @type {?} */\n        const elementFromPoint = this._document.elementFromPoint(x, y);\n        // If there's no element at the pointer position, then\n        // the client rect is probably scrolled out of the view.\n        if (!elementFromPoint) {\n            return false;\n        }\n        // The `ClientRect`, that we're using to find the container over which the user is\n        // hovering, doesn't give us any information on whether the element has been scrolled\n        // out of the view or whether it's overlapping with other containers. This means that\n        // we could end up transferring the item into a container that's invisible or is positioned\n        // below another one. We use the result from `elementFromPoint` to get the top-most element\n        // at the pointer position and to find whether it's one of the intersecting drop containers.\n        return elementFromPoint === this.element || this.element.contains(elementFromPoint);\n    }\n    /**\n     * Called by one of the connected drop lists when a dragging sequence has started.\n     * @param {?} sibling Sibling in which dragging has started.\n     * @return {?}\n     */\n    _startReceiving(sibling) {\n        /** @type {?} */\n        const activeSiblings = this._activeSiblings;\n        if (!activeSiblings.has(sibling)) {\n            activeSiblings.add(sibling);\n            this._cacheOwnPosition();\n        }\n    }\n    /**\n     * Called by a connected drop list when dragging has stopped.\n     * @param {?} sibling Sibling whose dragging has stopped.\n     * @return {?}\n     */\n    _stopReceiving(sibling) {\n        this._activeSiblings.delete(sibling);\n    }\n}\n/**\n * Updates the top/left positions of a `ClientRect`, as well as their bottom/right counterparts.\n * @param {?} clientRect `ClientRect` that should be updated.\n * @param {?} top Amount to add to the `top` position.\n * @param {?} left Amount to add to the `left` position.\n * @return {?}\n */\nfunction adjustClientRect(clientRect, top, left) {\n    clientRect.top += top;\n    clientRect.bottom = clientRect.top + clientRect.height;\n    clientRect.left += left;\n    clientRect.right = clientRect.left + clientRect.width;\n}\n/**\n * Finds the index of an item that matches a predicate function. Used as an equivalent\n * of `Array.prototype.find` which isn't part of the standard Google typings.\n * @template T\n * @param {?} array Array in which to look for matches.\n * @param {?} predicate Function used to determine whether an item is a match.\n * @return {?}\n */\nfunction findIndex(array, predicate) {\n    for (let i = 0; i < array.length; i++) {\n        if (predicate(array[i], i, array)) {\n            return i;\n        }\n    }\n    return -1;\n}\n/**\n * Checks whether some coordinates are within a `ClientRect`.\n * @param {?} clientRect ClientRect that is being checked.\n * @param {?} x Coordinates along the X axis.\n * @param {?} y Coordinates along the Y axis.\n * @return {?}\n */\nfunction isInsideClientRect(clientRect, x, y) {\n    const { top, bottom, left, right } = clientRect;\n    return y >= top && y <= bottom && x >= left && x <= right;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Event options that can be used to bind an active, capturing event.\n * @type {?}\n */\nconst activeCapturingEventOptions = normalizePassiveListenerOptions({\n    passive: false,\n    capture: true\n});\n/**\n * Service that keeps track of all the drag item and drop container\n * instances, and manages global event listeners on the `document`.\n * \\@docs-private\n * @template I, C\n */\n// Note: this class is generic, rather than referencing CdkDrag and CdkDropList directly, in order\n// to avoid circular imports. If we were to reference them here, importing the registry into the\n// classes that are registering themselves will introduce a circular import.\nclass DragDropRegistry {\n    /**\n     * @param {?} _ngZone\n     * @param {?} _document\n     */\n    constructor(_ngZone, _document) {\n        this._ngZone = _ngZone;\n        /**\n         * Registered drop container instances.\n         */\n        this._dropInstances = new Set();\n        /**\n         * Registered drag item instances.\n         */\n        this._dragInstances = new Set();\n        /**\n         * Drag item instances that are currently being dragged.\n         */\n        this._activeDragInstances = new Set();\n        /**\n         * Keeps track of the event listeners that we've bound to the `document`.\n         */\n        this._globalListeners = new Map();\n        /**\n         * Emits the `touchmove` or `mousemove` events that are dispatched\n         * while the user is dragging a drag item instance.\n         */\n        this.pointerMove = new Subject();\n        /**\n         * Emits the `touchend` or `mouseup` events that are dispatched\n         * while the user is dragging a drag item instance.\n         */\n        this.pointerUp = new Subject();\n        /**\n         * Event listener that will prevent the default browser action while the user is dragging.\n         * @param event Event whose default action should be prevented.\n         */\n        this._preventDefaultWhileDragging = (/**\n         * @param {?} event\n         * @return {?}\n         */\n        (event) => {\n            if (this._activeDragInstances.size) {\n                event.preventDefault();\n            }\n        });\n        this._document = _document;\n    }\n    /**\n     * Adds a drop container to the registry.\n     * @param {?} drop\n     * @return {?}\n     */\n    registerDropContainer(drop) {\n        if (!this._dropInstances.has(drop)) {\n            if (this.getDropContainer(drop.id)) {\n                throw Error(`Drop instance with id \"${drop.id}\" has already been registered.`);\n            }\n            this._dropInstances.add(drop);\n        }\n    }\n    /**\n     * Adds a drag item instance to the registry.\n     * @param {?} drag\n     * @return {?}\n     */\n    registerDragItem(drag) {\n        this._dragInstances.add(drag);\n        // The `touchmove` event gets bound once, ahead of time, because WebKit\n        // won't preventDefault on a dynamically-added `touchmove` listener.\n        // See https://bugs.webkit.org/show_bug.cgi?id=184250.\n        if (this._dragInstances.size === 1) {\n            this._ngZone.runOutsideAngular((/**\n             * @return {?}\n             */\n            () => {\n                // The event handler has to be explicitly active,\n                // because newer browsers make it passive by default.\n                this._document.addEventListener('touchmove', this._preventDefaultWhileDragging, activeCapturingEventOptions);\n            }));\n        }\n    }\n    /**\n     * Removes a drop container from the registry.\n     * @param {?} drop\n     * @return {?}\n     */\n    removeDropContainer(drop) {\n        this._dropInstances.delete(drop);\n    }\n    /**\n     * Removes a drag item instance from the registry.\n     * @param {?} drag\n     * @return {?}\n     */\n    removeDragItem(drag) {\n        this._dragInstances.delete(drag);\n        this.stopDragging(drag);\n        if (this._dragInstances.size === 0) {\n            this._document.removeEventListener('touchmove', this._preventDefaultWhileDragging, activeCapturingEventOptions);\n        }\n    }\n    /**\n     * Starts the dragging sequence for a drag instance.\n     * @param {?} drag Drag instance which is being dragged.\n     * @param {?} event Event that initiated the dragging.\n     * @return {?}\n     */\n    startDragging(drag, event) {\n        this._activeDragInstances.add(drag);\n        if (this._activeDragInstances.size === 1) {\n            /** @type {?} */\n            const isTouchEvent = event.type.startsWith('touch');\n            /** @type {?} */\n            const moveEvent = isTouchEvent ? 'touchmove' : 'mousemove';\n            /** @type {?} */\n            const upEvent = isTouchEvent ? 'touchend' : 'mouseup';\n            // We explicitly bind __active__ listeners here, because newer browsers will default to\n            // passive ones for `mousemove` and `touchmove`. The events need to be active, because we\n            // use `preventDefault` to prevent the page from scrolling while the user is dragging.\n            this._globalListeners\n                .set(moveEvent, {\n                handler: (/**\n                 * @param {?} e\n                 * @return {?}\n                 */\n                (e) => this.pointerMove.next((/** @type {?} */ (e)))),\n                options: activeCapturingEventOptions\n            })\n                .set(upEvent, {\n                handler: (/**\n                 * @param {?} e\n                 * @return {?}\n                 */\n                (e) => this.pointerUp.next((/** @type {?} */ (e)))),\n                options: true\n            })\n                // Preventing the default action on `mousemove` isn't enough to disable text selection\n                // on Safari so we need to prevent the selection event as well. Alternatively this can\n                // be done by setting `user-select: none` on the `body`, however it has causes a style\n                // recalculation which can be expensive on pages with a lot of elements.\n                .set('selectstart', {\n                handler: this._preventDefaultWhileDragging,\n                options: activeCapturingEventOptions\n            });\n            // TODO(crisbeto): prevent mouse wheel scrolling while\n            // dragging until we've set up proper scroll handling.\n            if (!isTouchEvent) {\n                this._globalListeners.set('wheel', {\n                    handler: this._preventDefaultWhileDragging,\n                    options: activeCapturingEventOptions\n                });\n            }\n            this._ngZone.runOutsideAngular((/**\n             * @return {?}\n             */\n            () => {\n                this._globalListeners.forEach((/**\n                 * @param {?} config\n                 * @param {?} name\n                 * @return {?}\n                 */\n                (config, name) => {\n                    this._document.addEventListener(name, config.handler, config.options);\n                }));\n            }));\n        }\n    }\n    /**\n     * Stops dragging a drag item instance.\n     * @param {?} drag\n     * @return {?}\n     */\n    stopDragging(drag) {\n        this._activeDragInstances.delete(drag);\n        if (this._activeDragInstances.size === 0) {\n            this._clearGlobalListeners();\n        }\n    }\n    /**\n     * Gets whether a drag item instance is currently being dragged.\n     * @param {?} drag\n     * @return {?}\n     */\n    isDragging(drag) {\n        return this._activeDragInstances.has(drag);\n    }\n    /**\n     * Gets a drop container by its id.\n     * @deprecated No longer being used. To be removed.\n     * \\@breaking-change 8.0.0\n     * @param {?} id\n     * @return {?}\n     */\n    getDropContainer(id) {\n        return Array.from(this._dropInstances).find((/**\n         * @param {?} instance\n         * @return {?}\n         */\n        instance => instance.id === id));\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._dragInstances.forEach((/**\n         * @param {?} instance\n         * @return {?}\n         */\n        instance => this.removeDragItem(instance)));\n        this._dropInstances.forEach((/**\n         * @param {?} instance\n         * @return {?}\n         */\n        instance => this.removeDropContainer(instance)));\n        this._clearGlobalListeners();\n        this.pointerMove.complete();\n        this.pointerUp.complete();\n    }\n    /**\n     * Clears out the global event listeners from the `document`.\n     * @private\n     * @return {?}\n     */\n    _clearGlobalListeners() {\n        this._globalListeners.forEach((/**\n         * @param {?} config\n         * @param {?} name\n         * @return {?}\n         */\n        (config, name) => {\n            this._document.removeEventListener(name, config.handler, config.options);\n        }));\n        this._globalListeners.clear();\n    }\n}\nDragDropRegistry.decorators = [\n    { type: Injectable, args: [{ providedIn: 'root' },] },\n];\n/** @nocollapse */\nDragDropRegistry.ctorParameters = () => [\n    { type: NgZone },\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\n];\n/** @nocollapse */ DragDropRegistry.ngInjectableDef = ɵɵdefineInjectable({ factory: function DragDropRegistry_Factory() { return new DragDropRegistry(ɵɵinject(NgZone), ɵɵinject(DOCUMENT)); }, token: DragDropRegistry, providedIn: \"root\" });\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Default configuration to be used when creating a `DragRef`.\n * @type {?}\n */\nconst DEFAULT_CONFIG = {\n    dragStartThreshold: 5,\n    pointerDirectionChangeThreshold: 5\n};\n/**\n * Service that allows for drag-and-drop functionality to be attached to DOM elements.\n */\nclass DragDrop {\n    /**\n     * @param {?} _document\n     * @param {?} _ngZone\n     * @param {?} _viewportRuler\n     * @param {?} _dragDropRegistry\n     */\n    constructor(_document, _ngZone, _viewportRuler, _dragDropRegistry) {\n        this._document = _document;\n        this._ngZone = _ngZone;\n        this._viewportRuler = _viewportRuler;\n        this._dragDropRegistry = _dragDropRegistry;\n    }\n    /**\n     * Turns an element into a draggable item.\n     * @template T\n     * @param {?} element Element to which to attach the dragging functionality.\n     * @param {?=} config Object used to configure the dragging behavior.\n     * @return {?}\n     */\n    createDrag(element, config = DEFAULT_CONFIG) {\n        return new DragRef(element, config, this._document, this._ngZone, this._viewportRuler, this._dragDropRegistry);\n    }\n    /**\n     * Turns an element into a drop list.\n     * @template T\n     * @param {?} element Element to which to attach the drop list functionality.\n     * @return {?}\n     */\n    createDropList(element) {\n        return new DropListRef(element, this._dragDropRegistry, this._document);\n    }\n}\nDragDrop.decorators = [\n    { type: Injectable, args: [{ providedIn: 'root' },] },\n];\n/** @nocollapse */\nDragDrop.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\n    { type: NgZone },\n    { type: ViewportRuler },\n    { type: DragDropRegistry }\n];\n/** @nocollapse */ DragDrop.ngInjectableDef = ɵɵdefineInjectable({ factory: function DragDrop_Factory() { return new DragDrop(ɵɵinject(DOCUMENT), ɵɵinject(NgZone), ɵɵinject(ViewportRuler), ɵɵinject(DragDropRegistry)); }, token: DragDrop, providedIn: \"root\" });\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Injection token that is used to provide a CdkDropList instance to CdkDrag.\n * Used for avoiding circular imports.\n * @type {?}\n */\nconst CDK_DROP_LIST = new InjectionToken('CDK_DROP_LIST');\n/**\n * Injection token that is used to provide a CdkDropList instance to CdkDrag.\n * Used for avoiding circular imports.\n * @deprecated Use `CDK_DROP_LIST` instead.\n * \\@breaking-change 8.0.0\n * @type {?}\n */\nconst CDK_DROP_LIST_CONTAINER = CDK_DROP_LIST;\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Injection token that can be used for a `CdkDrag` to provide itself as a parent to the\n * drag-specific child directive (`CdkDragHandle`, `CdkDragPreview` etc.). Used primarily\n * to avoid circular imports.\n * \\@docs-private\n * @type {?}\n */\nconst CDK_DRAG_PARENT = new InjectionToken('CDK_DRAG_PARENT');\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Handle that can be used to drag and CdkDrag instance.\n */\nclass CdkDragHandle {\n    /**\n     * @param {?} element\n     * @param {?=} parentDrag\n     */\n    constructor(element, parentDrag) {\n        this.element = element;\n        /**\n         * Emits when the state of the handle has changed.\n         */\n        this._stateChanges = new Subject();\n        this._disabled = false;\n        this._parentDrag = parentDrag;\n        toggleNativeDragInteractions(element.nativeElement, false);\n    }\n    /**\n     * Whether starting to drag through this handle is disabled.\n     * @return {?}\n     */\n    get disabled() { return this._disabled; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set disabled(value) {\n        this._disabled = coerceBooleanProperty(value);\n        this._stateChanges.next(this);\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._stateChanges.complete();\n    }\n}\nCdkDragHandle.decorators = [\n    { type: Directive, args: [{\n                selector: '[cdkDragHandle]',\n                host: {\n                    'class': 'cdk-drag-handle'\n                }\n            },] },\n];\n/** @nocollapse */\nCdkDragHandle.ctorParameters = () => [\n    { type: ElementRef },\n    { type: undefined, decorators: [{ type: Inject, args: [CDK_DRAG_PARENT,] }, { type: Optional }] }\n];\nCdkDragHandle.propDecorators = {\n    disabled: [{ type: Input, args: ['cdkDragHandleDisabled',] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Element that will be used as a template for the placeholder of a CdkDrag when\n * it is being dragged. The placeholder is displayed in place of the element being dragged.\n * @template T\n */\nclass CdkDragPlaceholder {\n    /**\n     * @param {?} templateRef\n     */\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nCdkDragPlaceholder.decorators = [\n    { type: Directive, args: [{\n                selector: 'ng-template[cdkDragPlaceholder]'\n            },] },\n];\n/** @nocollapse */\nCdkDragPlaceholder.ctorParameters = () => [\n    { type: TemplateRef }\n];\nCdkDragPlaceholder.propDecorators = {\n    data: [{ type: Input }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Element that will be used as a template for the preview\n * of a CdkDrag when it is being dragged.\n * @template T\n */\nclass CdkDragPreview {\n    /**\n     * @param {?} templateRef\n     */\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nCdkDragPreview.decorators = [\n    { type: Directive, args: [{\n                selector: 'ng-template[cdkDragPreview]'\n            },] },\n];\n/** @nocollapse */\nCdkDragPreview.ctorParameters = () => [\n    { type: TemplateRef }\n];\nCdkDragPreview.propDecorators = {\n    data: [{ type: Input }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Injection token that can be used to configure the behavior of `CdkDrag`.\n * @type {?}\n */\nconst CDK_DRAG_CONFIG = new InjectionToken('CDK_DRAG_CONFIG', {\n    providedIn: 'root',\n    factory: CDK_DRAG_CONFIG_FACTORY\n});\n/**\n * \\@docs-private\n * @return {?}\n */\nfunction CDK_DRAG_CONFIG_FACTORY() {\n    return { dragStartThreshold: 5, pointerDirectionChangeThreshold: 5 };\n}\n/**\n * Element that can be moved inside a CdkDropList container.\n * @template T\n */\nclass CdkDrag {\n    /**\n     * @param {?} element\n     * @param {?} dropContainer\n     * @param {?} _document\n     * @param {?} _ngZone\n     * @param {?} _viewContainerRef\n     * @param {?} config\n     * @param {?} _dir\n     * @param {?} dragDrop\n     * @param {?} _changeDetectorRef\n     */\n    constructor(element, dropContainer, _document, _ngZone, _viewContainerRef, config, _dir, dragDrop, _changeDetectorRef) {\n        this.element = element;\n        this.dropContainer = dropContainer;\n        this._document = _document;\n        this._ngZone = _ngZone;\n        this._viewContainerRef = _viewContainerRef;\n        this._dir = _dir;\n        this._changeDetectorRef = _changeDetectorRef;\n        this._destroyed = new Subject();\n        /**\n         * Amount of milliseconds to wait after the user has put their\n         * pointer down before starting to drag the element.\n         */\n        this.dragStartDelay = 0;\n        this._disabled = false;\n        /**\n         * Emits when the user starts dragging the item.\n         */\n        this.started = new EventEmitter();\n        /**\n         * Emits when the user has released a drag item, before any animations have started.\n         */\n        this.released = new EventEmitter();\n        /**\n         * Emits when the user stops dragging an item in the container.\n         */\n        this.ended = new EventEmitter();\n        /**\n         * Emits when the user has moved the item into a new container.\n         */\n        this.entered = new EventEmitter();\n        /**\n         * Emits when the user removes the item its container by dragging it into another container.\n         */\n        this.exited = new EventEmitter();\n        /**\n         * Emits when the user drops the item inside a container.\n         */\n        this.dropped = new EventEmitter();\n        /**\n         * Emits as the user is dragging the item. Use with caution,\n         * because this event will fire for every pixel that the user has dragged.\n         */\n        this.moved = new Observable((/**\n         * @param {?} observer\n         * @return {?}\n         */\n        (observer) => {\n            /** @type {?} */\n            const subscription = this._dragRef.moved.pipe(map((/**\n             * @param {?} movedEvent\n             * @return {?}\n             */\n            movedEvent => ({\n                source: this,\n                pointerPosition: movedEvent.pointerPosition,\n                event: movedEvent.event,\n                delta: movedEvent.delta\n            })))).subscribe(observer);\n            return (/**\n             * @return {?}\n             */\n            () => {\n                subscription.unsubscribe();\n            });\n        }));\n        this._dragRef = dragDrop.createDrag(element, config);\n        this._dragRef.data = this;\n        this._syncInputs(this._dragRef);\n        this._handleEvents(this._dragRef);\n    }\n    /**\n     * Whether starting to drag this element is disabled.\n     * @return {?}\n     */\n    get disabled() {\n        return this._disabled || (this.dropContainer && this.dropContainer.disabled);\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set disabled(value) {\n        this._disabled = coerceBooleanProperty(value);\n        this._dragRef.disabled = this._disabled;\n    }\n    /**\n     * Returns the element that is being used as a placeholder\n     * while the current element is being dragged.\n     * @return {?}\n     */\n    getPlaceholderElement() {\n        return this._dragRef.getPlaceholderElement();\n    }\n    /**\n     * Returns the root draggable element.\n     * @return {?}\n     */\n    getRootElement() {\n        return this._dragRef.getRootElement();\n    }\n    /**\n     * Resets a standalone drag item to its initial position.\n     * @return {?}\n     */\n    reset() {\n        this._dragRef.reset();\n    }\n    /**\n     * Gets the pixel coordinates of the draggable outside of a drop container.\n     * @return {?}\n     */\n    getFreeDragPosition() {\n        return this._dragRef.getFreeDragPosition();\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterViewInit() {\n        // We need to wait for the zone to stabilize, in order for the reference\n        // element to be in the proper place in the DOM. This is mostly relevant\n        // for draggable elements inside portals since they get stamped out in\n        // their original DOM position and then they get transferred to the portal.\n        this._ngZone.onStable.asObservable()\n            .pipe(take(1), takeUntil(this._destroyed))\n            .subscribe((/**\n         * @return {?}\n         */\n        () => {\n            this._updateRootElement();\n            // Listen for any newly-added handles.\n            this._handles.changes.pipe(startWith(this._handles), \n            // Sync the new handles with the DragRef.\n            tap((/**\n             * @param {?} handles\n             * @return {?}\n             */\n            (handles) => {\n                /** @type {?} */\n                const childHandleElements = handles\n                    .filter((/**\n                 * @param {?} handle\n                 * @return {?}\n                 */\n                handle => handle._parentDrag === this))\n                    .map((/**\n                 * @param {?} handle\n                 * @return {?}\n                 */\n                handle => handle.element));\n                this._dragRef.withHandles(childHandleElements);\n            })), \n            // Listen if the state of any of the handles changes.\n            switchMap((/**\n             * @param {?} handles\n             * @return {?}\n             */\n            (handles) => {\n                return merge(...handles.map((/**\n                 * @param {?} item\n                 * @return {?}\n                 */\n                item => item._stateChanges)));\n            })), takeUntil(this._destroyed)).subscribe((/**\n             * @param {?} handleInstance\n             * @return {?}\n             */\n            handleInstance => {\n                // Enabled/disable the handle that changed in the DragRef.\n                /** @type {?} */\n                const dragRef = this._dragRef;\n                /** @type {?} */\n                const handle = handleInstance.element.nativeElement;\n                handleInstance.disabled ? dragRef.disableHandle(handle) : dragRef.enableHandle(handle);\n            }));\n            if (this.freeDragPosition) {\n                this._dragRef.setFreeDragPosition(this.freeDragPosition);\n            }\n        }));\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        /** @type {?} */\n        const rootSelectorChange = changes['rootElementSelector'];\n        /** @type {?} */\n        const positionChange = changes['freeDragPosition'];\n        // We don't have to react to the first change since it's being\n        // handled in `ngAfterViewInit` where it needs to be deferred.\n        if (rootSelectorChange && !rootSelectorChange.firstChange) {\n            this._updateRootElement();\n        }\n        // Skip the first change since it's being handled in `ngAfterViewInit`.\n        if (positionChange && !positionChange.firstChange && this.freeDragPosition) {\n            this._dragRef.setFreeDragPosition(this.freeDragPosition);\n        }\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._destroyed.next();\n        this._destroyed.complete();\n        this._dragRef.dispose();\n    }\n    /**\n     * Syncs the root element with the `DragRef`.\n     * @private\n     * @return {?}\n     */\n    _updateRootElement() {\n        /** @type {?} */\n        const element = this.element.nativeElement;\n        /** @type {?} */\n        const rootElement = this.rootElementSelector ?\n            getClosestMatchingAncestor(element, this.rootElementSelector) : element;\n        if (rootElement && rootElement.nodeType !== this._document.ELEMENT_NODE) {\n            throw Error(`cdkDrag must be attached to an element node. ` +\n                `Currently attached to \"${rootElement.nodeName}\".`);\n        }\n        this._dragRef.withRootElement(rootElement || element);\n    }\n    /**\n     * Gets the boundary element, based on the `boundaryElementSelector`.\n     * @private\n     * @return {?}\n     */\n    _getBoundaryElement() {\n        /** @type {?} */\n        const selector = this.boundaryElementSelector;\n        return selector ? getClosestMatchingAncestor(this.element.nativeElement, selector) : null;\n    }\n    /**\n     * Syncs the inputs of the CdkDrag with the options of the underlying DragRef.\n     * @private\n     * @param {?} ref\n     * @return {?}\n     */\n    _syncInputs(ref) {\n        ref.beforeStarted.subscribe((/**\n         * @return {?}\n         */\n        () => {\n            if (!ref.isDragging()) {\n                /** @type {?} */\n                const dir = this._dir;\n                /** @type {?} */\n                const placeholder = this._placeholderTemplate ? {\n                    template: this._placeholderTemplate.templateRef,\n                    context: this._placeholderTemplate.data,\n                    viewContainer: this._viewContainerRef\n                } : null;\n                /** @type {?} */\n                const preview = this._previewTemplate ? {\n                    template: this._previewTemplate.templateRef,\n                    context: this._previewTemplate.data,\n                    viewContainer: this._viewContainerRef\n                } : null;\n                ref.disabled = this.disabled;\n                ref.lockAxis = this.lockAxis;\n                ref.dragStartDelay = coerceNumberProperty(this.dragStartDelay);\n                ref.constrainPosition = this.constrainPosition;\n                ref\n                    .withBoundaryElement(this._getBoundaryElement())\n                    .withPlaceholderTemplate(placeholder)\n                    .withPreviewTemplate(preview);\n                if (dir) {\n                    ref.withDirection(dir.value);\n                }\n            }\n        }));\n    }\n    /**\n     * Handles the events from the underlying `DragRef`.\n     * @private\n     * @param {?} ref\n     * @return {?}\n     */\n    _handleEvents(ref) {\n        ref.started.subscribe((/**\n         * @return {?}\n         */\n        () => {\n            this.started.emit({ source: this });\n            // Since all of these events run outside of change detection,\n            // we need to ensure that everything is marked correctly.\n            this._changeDetectorRef.markForCheck();\n        }));\n        ref.released.subscribe((/**\n         * @return {?}\n         */\n        () => {\n            this.released.emit({ source: this });\n        }));\n        ref.ended.subscribe((/**\n         * @return {?}\n         */\n        () => {\n            this.ended.emit({ source: this });\n            // Since all of these events run outside of change detection,\n            // we need to ensure that everything is marked correctly.\n            this._changeDetectorRef.markForCheck();\n        }));\n        ref.entered.subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => {\n            this.entered.emit({\n                container: event.container.data,\n                item: this\n            });\n        }));\n        ref.exited.subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => {\n            this.exited.emit({\n                container: event.container.data,\n                item: this\n            });\n        }));\n        ref.dropped.subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => {\n            this.dropped.emit({\n                previousIndex: event.previousIndex,\n                currentIndex: event.currentIndex,\n                previousContainer: event.previousContainer.data,\n                container: event.container.data,\n                isPointerOverContainer: event.isPointerOverContainer,\n                item: this\n            });\n        }));\n    }\n}\nCdkDrag.decorators = [\n    { type: Directive, args: [{\n                selector: '[cdkDrag]',\n                exportAs: 'cdkDrag',\n                host: {\n                    'class': 'cdk-drag',\n                    '[class.cdk-drag-disabled]': 'disabled',\n                    '[class.cdk-drag-dragging]': '_dragRef.isDragging()',\n                },\n                providers: [{ provide: CDK_DRAG_PARENT, useExisting: CdkDrag }]\n            },] },\n];\n/** @nocollapse */\nCdkDrag.ctorParameters = () => [\n    { type: ElementRef },\n    { type: undefined, decorators: [{ type: Inject, args: [CDK_DROP_LIST,] }, { type: Optional }, { type: SkipSelf }] },\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\n    { type: NgZone },\n    { type: ViewContainerRef },\n    { type: undefined, decorators: [{ type: Inject, args: [CDK_DRAG_CONFIG,] }] },\n    { type: Directionality, decorators: [{ type: Optional }] },\n    { type: DragDrop },\n    { type: ChangeDetectorRef }\n];\nCdkDrag.propDecorators = {\n    _handles: [{ type: ContentChildren, args: [CdkDragHandle, { descendants: true },] }],\n    _previewTemplate: [{ type: ContentChild, args: [CdkDragPreview, { static: false },] }],\n    _placeholderTemplate: [{ type: ContentChild, args: [CdkDragPlaceholder, { static: false },] }],\n    data: [{ type: Input, args: ['cdkDragData',] }],\n    lockAxis: [{ type: Input, args: ['cdkDragLockAxis',] }],\n    rootElementSelector: [{ type: Input, args: ['cdkDragRootElement',] }],\n    boundaryElementSelector: [{ type: Input, args: ['cdkDragBoundary',] }],\n    dragStartDelay: [{ type: Input, args: ['cdkDragStartDelay',] }],\n    freeDragPosition: [{ type: Input, args: ['cdkDragFreeDragPosition',] }],\n    disabled: [{ type: Input, args: ['cdkDragDisabled',] }],\n    constrainPosition: [{ type: Input, args: ['cdkDragConstrainPosition',] }],\n    started: [{ type: Output, args: ['cdkDragStarted',] }],\n    released: [{ type: Output, args: ['cdkDragReleased',] }],\n    ended: [{ type: Output, args: ['cdkDragEnded',] }],\n    entered: [{ type: Output, args: ['cdkDragEntered',] }],\n    exited: [{ type: Output, args: ['cdkDragExited',] }],\n    dropped: [{ type: Output, args: ['cdkDragDropped',] }],\n    moved: [{ type: Output, args: ['cdkDragMoved',] }]\n};\n/**\n * Gets the closest ancestor of an element that matches a selector.\n * @param {?} element\n * @param {?} selector\n * @return {?}\n */\nfunction getClosestMatchingAncestor(element, selector) {\n    /** @type {?} */\n    let currentElement = (/** @type {?} */ (element.parentElement));\n    while (currentElement) {\n        // IE doesn't support `matches` so we have to fall back to `msMatchesSelector`.\n        if (currentElement.matches ? currentElement.matches(selector) :\n            ((/** @type {?} */ (currentElement))).msMatchesSelector(selector)) {\n            return currentElement;\n        }\n        currentElement = currentElement.parentElement;\n    }\n    return null;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Declaratively connects sibling `cdkDropList` instances together. All of the `cdkDropList`\n * elements that are placed inside a `cdkDropListGroup` will be connected to each other\n * automatically. Can be used as an alternative to the `cdkDropListConnectedTo` input\n * from `cdkDropList`.\n * @template T\n */\nclass CdkDropListGroup {\n    constructor() {\n        /**\n         * Drop lists registered inside the group.\n         */\n        this._items = new Set();\n        this._disabled = false;\n    }\n    /**\n     * Whether starting a dragging sequence from inside this group is disabled.\n     * @return {?}\n     */\n    get disabled() { return this._disabled; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set disabled(value) {\n        this._disabled = coerceBooleanProperty(value);\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this._items.clear();\n    }\n}\nCdkDropListGroup.decorators = [\n    { type: Directive, args: [{\n                selector: '[cdkDropListGroup]',\n                exportAs: 'cdkDropListGroup',\n            },] },\n];\nCdkDropListGroup.propDecorators = {\n    disabled: [{ type: Input, args: ['cdkDropListGroupDisabled',] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Counter used to generate unique ids for drop zones.\n * @type {?}\n */\nlet _uniqueIdCounter$1 = 0;\nconst ɵ0 = undefined;\n// @breaking-change 8.0.0 `CdkDropList` implements `CdkDropListContainer` for backwards\n// compatiblity. The implements clause, as well as all the methods that it enforces can\n// be removed when `CdkDropListContainer` is deleted.\n/**\n * Container that wraps a set of draggable items.\n * @template T\n */\nclass CdkDropList {\n    /**\n     * @param {?} element\n     * @param {?} dragDrop\n     * @param {?} _changeDetectorRef\n     * @param {?=} _dir\n     * @param {?=} _group\n     */\n    constructor(element, dragDrop, _changeDetectorRef, _dir, _group) {\n        this.element = element;\n        this._changeDetectorRef = _changeDetectorRef;\n        this._dir = _dir;\n        this._group = _group;\n        /**\n         * Emits when the list has been destroyed.\n         */\n        this._destroyed = new Subject();\n        /**\n         * Other draggable containers that this container is connected to and into which the\n         * container's items can be transferred. Can either be references to other drop containers,\n         * or their unique IDs.\n         */\n        this.connectedTo = [];\n        /**\n         * Direction in which the list is oriented.\n         */\n        this.orientation = 'vertical';\n        /**\n         * Unique ID for the drop zone. Can be used as a reference\n         * in the `connectedTo` of another `CdkDropList`.\n         */\n        this.id = `cdk-drop-list-${_uniqueIdCounter$1++}`;\n        this._disabled = false;\n        this._sortingDisabled = false;\n        /**\n         * Function that is used to determine whether an item\n         * is allowed to be moved into a drop container.\n         */\n        this.enterPredicate = (/**\n         * @return {?}\n         */\n        () => true);\n        /**\n         * Emits when the user drops an item inside the container.\n         */\n        this.dropped = new EventEmitter();\n        /**\n         * Emits when the user has moved a new drag item into this container.\n         */\n        this.entered = new EventEmitter();\n        /**\n         * Emits when the user removes an item from the container\n         * by dragging it into another container.\n         */\n        this.exited = new EventEmitter();\n        /**\n         * Emits as the user is swapping items while actively dragging.\n         */\n        this.sorted = new EventEmitter();\n        this._dropListRef = dragDrop.createDropList(element);\n        this._dropListRef.data = this;\n        this._dropListRef.enterPredicate = (/**\n         * @param {?} drag\n         * @param {?} drop\n         * @return {?}\n         */\n        (drag, drop) => {\n            return this.enterPredicate(drag.data, drop.data);\n        });\n        this._syncInputs(this._dropListRef);\n        this._handleEvents(this._dropListRef);\n        CdkDropList._dropLists.push(this);\n        if (_group) {\n            _group._items.add(this);\n        }\n    }\n    /**\n     * Whether starting a dragging sequence from this container is disabled.\n     * @return {?}\n     */\n    get disabled() {\n        return this._disabled || (!!this._group && this._group.disabled);\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set disabled(value) {\n        this._disabled = coerceBooleanProperty(value);\n    }\n    /**\n     * Whether sorting within this drop list is disabled.\n     * @return {?}\n     */\n    get sortingDisabled() { return this._sortingDisabled; }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set sortingDisabled(value) {\n        this._sortingDisabled = coerceBooleanProperty(value);\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterContentInit() {\n        this._draggables.changes\n            .pipe(startWith(this._draggables), takeUntil(this._destroyed))\n            .subscribe((/**\n         * @param {?} items\n         * @return {?}\n         */\n        (items) => {\n            this._dropListRef.withItems(items.map((/**\n             * @param {?} drag\n             * @return {?}\n             */\n            drag => drag._dragRef)));\n        }));\n    }\n    /**\n     * @return {?}\n     */\n    ngOnDestroy() {\n        /** @type {?} */\n        const index = CdkDropList._dropLists.indexOf(this);\n        if (index > -1) {\n            CdkDropList._dropLists.splice(index, 1);\n        }\n        if (this._group) {\n            this._group._items.delete(this);\n        }\n        this._dropListRef.dispose();\n        this._destroyed.next();\n        this._destroyed.complete();\n    }\n    /**\n     * Starts dragging an item.\n     * @return {?}\n     */\n    start() {\n        this._dropListRef.start();\n    }\n    /**\n     * Drops an item into this container.\n     * @param {?} item Item being dropped into the container.\n     * @param {?} currentIndex Index at which the item should be inserted.\n     * @param {?} previousContainer Container from which the item got dragged in.\n     * @param {?} isPointerOverContainer Whether the user's pointer was over the\n     *    container when the item was dropped.\n     * @return {?}\n     */\n    drop(item, currentIndex, previousContainer, isPointerOverContainer) {\n        this._dropListRef.drop(item._dragRef, currentIndex, ((/** @type {?} */ (previousContainer)))._dropListRef, isPointerOverContainer);\n    }\n    /**\n     * Emits an event to indicate that the user moved an item into the container.\n     * @param {?} item Item that was moved into the container.\n     * @param {?} pointerX Position of the item along the X axis.\n     * @param {?} pointerY Position of the item along the Y axis.\n     * @return {?}\n     */\n    enter(item, pointerX, pointerY) {\n        this._dropListRef.enter(item._dragRef, pointerX, pointerY);\n    }\n    /**\n     * Removes an item from the container after it was dragged into another container by the user.\n     * @param {?} item Item that was dragged out.\n     * @return {?}\n     */\n    exit(item) {\n        this._dropListRef.exit(item._dragRef);\n    }\n    /**\n     * Figures out the index of an item in the container.\n     * @param {?} item Item whose index should be determined.\n     * @return {?}\n     */\n    getItemIndex(item) {\n        return this._dropListRef.getItemIndex(item._dragRef);\n    }\n    /**\n     * Sorts an item inside the container based on its position.\n     * @param {?} item Item to be sorted.\n     * @param {?} pointerX Position of the item along the X axis.\n     * @param {?} pointerY Position of the item along the Y axis.\n     * @param {?} pointerDelta Direction in which the pointer is moving along each axis.\n     * @return {?}\n     */\n    _sortItem(item, pointerX, pointerY, pointerDelta) {\n        return this._dropListRef._sortItem(item._dragRef, pointerX, pointerY, pointerDelta);\n    }\n    /**\n     * Figures out whether an item should be moved into a sibling\n     * drop container, based on its current position.\n     * @param {?} item Drag item that is being moved.\n     * @param {?} x Position of the item along the X axis.\n     * @param {?} y Position of the item along the Y axis.\n     * @return {?}\n     */\n    _getSiblingContainerFromPosition(item, x, y) {\n        /** @type {?} */\n        const result = this._dropListRef._getSiblingContainerFromPosition(item._dragRef, x, y);\n        return result ? result.data : null;\n    }\n    /**\n     * Checks whether the user's pointer is positioned over the container.\n     * @param {?} x Pointer position along the X axis.\n     * @param {?} y Pointer position along the Y axis.\n     * @return {?}\n     */\n    _isOverContainer(x, y) {\n        return this._dropListRef._isOverContainer(x, y);\n    }\n    /**\n     * Syncs the inputs of the CdkDropList with the options of the underlying DropListRef.\n     * @private\n     * @param {?} ref\n     * @return {?}\n     */\n    _syncInputs(ref) {\n        if (this._dir) {\n            this._dir.change\n                .pipe(startWith(this._dir.value), takeUntil(this._destroyed))\n                .subscribe((/**\n             * @param {?} value\n             * @return {?}\n             */\n            value => ref.withDirection(value)));\n        }\n        ref.beforeStarted.subscribe((/**\n         * @return {?}\n         */\n        () => {\n            /** @type {?} */\n            const siblings = coerceArray(this.connectedTo).map((/**\n             * @param {?} drop\n             * @return {?}\n             */\n            drop => {\n                return typeof drop === 'string' ?\n                    (/** @type {?} */ (CdkDropList._dropLists.find((/**\n                     * @param {?} list\n                     * @return {?}\n                     */\n                    list => list.id === drop)))) : drop;\n            }));\n            if (this._group) {\n                this._group._items.forEach((/**\n                 * @param {?} drop\n                 * @return {?}\n                 */\n                drop => {\n                    if (siblings.indexOf(drop) === -1) {\n                        siblings.push(drop);\n                    }\n                }));\n            }\n            ref.disabled = this.disabled;\n            ref.lockAxis = this.lockAxis;\n            ref.sortingDisabled = this.sortingDisabled;\n            ref\n                .connectedTo(siblings.filter((/**\n             * @param {?} drop\n             * @return {?}\n             */\n            drop => drop && drop !== this)).map((/**\n             * @param {?} list\n             * @return {?}\n             */\n            list => list._dropListRef)))\n                .withOrientation(this.orientation);\n        }));\n    }\n    /**\n     * Handles events from the underlying DropListRef.\n     * @private\n     * @param {?} ref\n     * @return {?}\n     */\n    _handleEvents(ref) {\n        ref.beforeStarted.subscribe((/**\n         * @return {?}\n         */\n        () => {\n            this._changeDetectorRef.markForCheck();\n        }));\n        ref.entered.subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => {\n            this.entered.emit({\n                container: this,\n                item: event.item.data\n            });\n        }));\n        ref.exited.subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => {\n            this.exited.emit({\n                container: this,\n                item: event.item.data\n            });\n            this._changeDetectorRef.markForCheck();\n        }));\n        ref.sorted.subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => {\n            this.sorted.emit({\n                previousIndex: event.previousIndex,\n                currentIndex: event.currentIndex,\n                container: this,\n                item: event.item.data\n            });\n        }));\n        ref.dropped.subscribe((/**\n         * @param {?} event\n         * @return {?}\n         */\n        event => {\n            this.dropped.emit({\n                previousIndex: event.previousIndex,\n                currentIndex: event.currentIndex,\n                previousContainer: event.previousContainer.data,\n                container: event.container.data,\n                item: event.item.data,\n                isPointerOverContainer: event.isPointerOverContainer\n            });\n            // Mark for check since all of these events run outside of change\n            // detection and we're not guaranteed for something else to have triggered it.\n            this._changeDetectorRef.markForCheck();\n        }));\n    }\n}\n/**\n * Keeps track of the drop lists that are currently on the page.\n */\nCdkDropList._dropLists = [];\nCdkDropList.decorators = [\n    { type: Directive, args: [{\n                selector: '[cdkDropList], cdk-drop-list',\n                exportAs: 'cdkDropList',\n                providers: [\n                    // Prevent child drop lists from picking up the same group as their parent.\n                    { provide: CdkDropListGroup, useValue: ɵ0 },\n                    { provide: CDK_DROP_LIST_CONTAINER, useExisting: CdkDropList },\n                ],\n                host: {\n                    'class': 'cdk-drop-list',\n                    '[id]': 'id',\n                    '[class.cdk-drop-list-disabled]': 'disabled',\n                    '[class.cdk-drop-list-dragging]': '_dropListRef.isDragging()',\n                    '[class.cdk-drop-list-receiving]': '_dropListRef.isReceiving()',\n                }\n            },] },\n];\n/** @nocollapse */\nCdkDropList.ctorParameters = () => [\n    { type: ElementRef },\n    { type: DragDrop },\n    { type: ChangeDetectorRef },\n    { type: Directionality, decorators: [{ type: Optional }] },\n    { type: CdkDropListGroup, decorators: [{ type: Optional }, { type: SkipSelf }] }\n];\nCdkDropList.propDecorators = {\n    _draggables: [{ type: ContentChildren, args: [forwardRef((/**\n                 * @return {?}\n                 */\n                () => CdkDrag)), {\n                    // Explicitly set to false since some of the logic below makes assumptions about it.\n                    // The `.withItems` call below should be updated if we ever need to switch this to `true`.\n                    descendants: false\n                },] }],\n    connectedTo: [{ type: Input, args: ['cdkDropListConnectedTo',] }],\n    data: [{ type: Input, args: ['cdkDropListData',] }],\n    orientation: [{ type: Input, args: ['cdkDropListOrientation',] }],\n    id: [{ type: Input }],\n    lockAxis: [{ type: Input, args: ['cdkDropListLockAxis',] }],\n    disabled: [{ type: Input, args: ['cdkDropListDisabled',] }],\n    sortingDisabled: [{ type: Input, args: ['cdkDropListSortingDisabled',] }],\n    enterPredicate: [{ type: Input, args: ['cdkDropListEnterPredicate',] }],\n    dropped: [{ type: Output, args: ['cdkDropListDropped',] }],\n    entered: [{ type: Output, args: ['cdkDropListEntered',] }],\n    exited: [{ type: Output, args: ['cdkDropListExited',] }],\n    sorted: [{ type: Output, args: ['cdkDropListSorted',] }]\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass DragDropModule {\n}\nDragDropModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [\n                    CdkDropList,\n                    CdkDropListGroup,\n                    CdkDrag,\n                    CdkDragHandle,\n                    CdkDragPreview,\n                    CdkDragPlaceholder,\n                ],\n                exports: [\n                    CdkDropList,\n                    CdkDropListGroup,\n                    CdkDrag,\n                    CdkDragHandle,\n                    CdkDragPreview,\n                    CdkDragPlaceholder,\n                ],\n                providers: [\n                    DragDrop,\n                ]\n            },] },\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { DragDrop, DragRef, DropListRef, CdkDropList, CDK_DROP_LIST, CDK_DROP_LIST_CONTAINER, moveItemInArray, transferArrayItem, copyArrayItem, DragDropModule, DragDropRegistry, CdkDropListGroup, CDK_DRAG_CONFIG_FACTORY, CDK_DRAG_CONFIG, CdkDrag, CdkDragHandle, CdkDragPreview, CdkDragPlaceholder, CDK_DRAG_PARENT as ɵb };\n//# sourceMappingURL=drag-drop.js.map\n","import { ChangeDetectionStrategy, Component, Input, OnInit } from '@angular/core';\n\nexport interface Crumb {\n  name: string;\n  link?: string;\n}\n@Component({\n  selector: 'ngx-breadcrumbs',\n  templateUrl: './breadcrumbs.component.html',\n  styleUrls: ['./breadcrumbs.component.scss'],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class BreadcrumbsComponent implements OnInit {\n  @Input()\n  readonly title: string;\n  @Input()\n  crumbs: ReadonlyArray<Crumb>;\n\n  constructor() {}\n\n  ngOnInit() {}\n}\n","/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n *\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}\n * tslint:disable\n */ \nvar styles = [\"[_nghost-%COMP%]{margin-bottom:24px;display:block}\"];\nexport { styles as styles };\n","/**\n * @fileoverview This file was generated by the Angular template compiler. Do not edit.\n *\n * @suppress {suspiciousCode,uselessCode,missingProperties,missingOverride,checkTypes}\n * tslint:disable\n */ \nimport * as i0 from \"./breadcrumbs.component.scss.shim.ngstyle\";\nimport * as i1 from \"@angular/core\";\nimport * as i2 from \"@angular/router\";\nimport * as i3 from \"@angular/common\";\nimport * as i4 from \"../../../../node_modules/@angular/material/icon/typings/index.ngfactory\";\nimport * as i5 from \"@angular/material/icon\";\nimport * as i6 from \"@angular/flex-layout/flex\";\nimport * as i7 from \"@angular/flex-layout/core\";\nimport * as i8 from \"./breadcrumbs.component\";\nvar styles_BreadcrumbsComponent = [i0.styles];\nvar RenderType_BreadcrumbsComponent = i1.ɵcrt({ encapsulation: 0, styles: styles_BreadcrumbsComponent, data: {} });\nexport { RenderType_BreadcrumbsComponent as RenderType_BreadcrumbsComponent };\nfunction View_BreadcrumbsComponent_2(_l) { return i1.ɵvid(0, [(_l()(), i1.ɵeld(0, 0, null, null, 3, \"a\", [[\"class\", \"crumb link\"]], [[1, \"target\", 0], [8, \"href\", 4]], [[null, \"click\"]], function (_v, en, $event) { var ad = true; if ((\"click\" === en)) {\n        var pd_0 = (i1.ɵnov(_v, 1).onClick($event.button, $event.ctrlKey, $event.metaKey, $event.shiftKey) !== false);\n        ad = (pd_0 && ad);\n    } return ad; }, null, null)), i1.ɵdid(1, 671744, null, 0, i2.RouterLinkWithHref, [i2.Router, i2.ActivatedRoute, i3.LocationStrategy], { routerLink: [0, \"routerLink\"] }, null), i1.ɵpad(2, 1), (_l()(), i1.ɵted(3, null, [\"\", \"\"]))], function (_ck, _v) { var currVal_2 = _ck(_v, 2, 0, _v.parent.context.$implicit.link); _ck(_v, 1, 0, currVal_2); }, function (_ck, _v) { var currVal_0 = i1.ɵnov(_v, 1).target; var currVal_1 = i1.ɵnov(_v, 1).href; _ck(_v, 0, 0, currVal_0, currVal_1); var currVal_3 = _v.parent.context.$implicit.name; _ck(_v, 3, 0, currVal_3); }); }\nfunction View_BreadcrumbsComponent_3(_l) { return i1.ɵvid(0, [(_l()(), i1.ɵeld(0, 0, null, null, 1, \"div\", [[\"class\", \"link\"]], null, null, null, null, null)), (_l()(), i1.ɵted(1, null, [\"\", \"\"]))], null, function (_ck, _v) { var currVal_0 = _v.parent.context.$implicit.name; _ck(_v, 1, 0, currVal_0); }); }\nfunction View_BreadcrumbsComponent_4(_l) { return i1.ɵvid(0, [(_l()(), i1.ɵeld(0, 0, null, null, 2, \"mat-icon\", [[\"class\", \"chevron mat-icon notranslate\"], [\"role\", \"img\"]], [[2, \"mat-icon-inline\", null], [2, \"mat-icon-no-color\", null]], null, null, i4.View_MatIcon_0, i4.RenderType_MatIcon)), i1.ɵdid(1, 9158656, null, 0, i5.MatIcon, [i1.ElementRef, i5.MatIconRegistry, [8, null], [2, i5.MAT_ICON_LOCATION]], null, null), (_l()(), i1.ɵted(-1, 0, [\"chevron_right\"]))], function (_ck, _v) { _ck(_v, 1, 0); }, function (_ck, _v) { var currVal_0 = i1.ɵnov(_v, 1).inline; var currVal_1 = (((i1.ɵnov(_v, 1).color !== \"primary\") && (i1.ɵnov(_v, 1).color !== \"accent\")) && (i1.ɵnov(_v, 1).color !== \"warn\")); _ck(_v, 0, 0, currVal_0, currVal_1); }); }\nfunction View_BreadcrumbsComponent_1(_l) { return i1.ɵvid(0, [(_l()(), i1.ɵeld(0, 0, null, null, 9, \"div\", [[\"class\", \"crumb\"], [\"fxLayout\", \"row\"], [\"fxLayoutAlign\", \"start center\"]], null, null, null, null, null)), i1.ɵdid(1, 671744, null, 0, i6.DefaultLayoutDirective, [i1.ElementRef, i7.StyleUtils, [2, i6.LayoutStyleBuilder], i7.MediaMarshaller], { fxLayout: [0, \"fxLayout\"] }, null), i1.ɵdid(2, 671744, null, 0, i6.DefaultLayoutAlignDirective, [i1.ElementRef, i7.StyleUtils, [2, i6.LayoutAlignStyleBuilder], i7.MediaMarshaller], { fxLayoutAlign: [0, \"fxLayoutAlign\"] }, null), i1.ɵdid(3, 16384, null, 0, i3.NgSwitch, [], { ngSwitch: [0, \"ngSwitch\"] }, null), (_l()(), i1.ɵand(16777216, null, null, 1, null, View_BreadcrumbsComponent_2)), i1.ɵdid(5, 278528, null, 0, i3.NgSwitchCase, [i1.ViewContainerRef, i1.TemplateRef, i3.NgSwitch], { ngSwitchCase: [0, \"ngSwitchCase\"] }, null), (_l()(), i1.ɵand(16777216, null, null, 1, null, View_BreadcrumbsComponent_3)), i1.ɵdid(7, 16384, null, 0, i3.NgSwitchDefault, [i1.ViewContainerRef, i1.TemplateRef, i3.NgSwitch], null, null), (_l()(), i1.ɵand(16777216, null, null, 1, null, View_BreadcrumbsComponent_4)), i1.ɵdid(9, 16384, null, 0, i3.NgIf, [i1.ViewContainerRef, i1.TemplateRef], { ngIf: [0, \"ngIf\"] }, null)], function (_ck, _v) { var currVal_0 = \"row\"; _ck(_v, 1, 0, currVal_0); var currVal_1 = \"start center\"; _ck(_v, 2, 0, currVal_1); var currVal_2 = !!_v.context.$implicit.link; _ck(_v, 3, 0, currVal_2); var currVal_3 = true; _ck(_v, 5, 0, currVal_3); var currVal_4 = !_v.context.last; _ck(_v, 9, 0, currVal_4); }, null); }\nexport function View_BreadcrumbsComponent_0(_l) { return i1.ɵvid(2, [(_l()(), i1.ɵeld(0, 0, null, null, 1, \"div\", [[\"class\", \"title\"]], null, null, null, null, null)), (_l()(), i1.ɵted(1, null, [\"\", \"\"])), (_l()(), i1.ɵeld(2, 0, null, null, 4, \"div\", [[\"class\", \"crumbs\"], [\"fxLayout\", \"row\"], [\"fxLayoutAlign\", \"start center\"]], null, null, null, null, null)), i1.ɵdid(3, 671744, null, 0, i6.DefaultLayoutDirective, [i1.ElementRef, i7.StyleUtils, [2, i6.LayoutStyleBuilder], i7.MediaMarshaller], { fxLayout: [0, \"fxLayout\"] }, null), i1.ɵdid(4, 671744, null, 0, i6.DefaultLayoutAlignDirective, [i1.ElementRef, i7.StyleUtils, [2, i6.LayoutAlignStyleBuilder], i7.MediaMarshaller], { fxLayoutAlign: [0, \"fxLayoutAlign\"] }, null), (_l()(), i1.ɵand(16777216, null, null, 1, null, View_BreadcrumbsComponent_1)), i1.ɵdid(6, 278528, null, 0, i3.NgForOf, [i1.ViewContainerRef, i1.TemplateRef, i1.IterableDiffers], { ngForOf: [0, \"ngForOf\"] }, null)], function (_ck, _v) { var _co = _v.component; var currVal_1 = \"row\"; _ck(_v, 3, 0, currVal_1); var currVal_2 = \"start center\"; _ck(_v, 4, 0, currVal_2); var currVal_3 = _co.crumbs; _ck(_v, 6, 0, currVal_3); }, function (_ck, _v) { var _co = _v.component; var currVal_0 = _co.title; _ck(_v, 1, 0, currVal_0); }); }\nexport function View_BreadcrumbsComponent_Host_0(_l) { return i1.ɵvid(0, [(_l()(), i1.ɵeld(0, 0, null, null, 1, \"ngx-breadcrumbs\", [], null, null, null, View_BreadcrumbsComponent_0, RenderType_BreadcrumbsComponent)), i1.ɵdid(1, 114688, null, 0, i8.BreadcrumbsComponent, [], null, null)], function (_ck, _v) { _ck(_v, 1, 0); }, null); }\nvar BreadcrumbsComponentNgFactory = i1.ɵccf(\"ngx-breadcrumbs\", i8.BreadcrumbsComponent, View_BreadcrumbsComponent_Host_0, { title: \"title\", crumbs: \"crumbs\" }, {}, []);\nexport { BreadcrumbsComponentNgFactory as BreadcrumbsComponentNgFactory };\n","<div class=\"title\">{{ title }}</div>\n<div class=\"crumbs\" fxLayout=\"row\" fxLayoutAlign=\"start center\">\n  <div\n    class=\"crumb\"\n    *ngFor=\"let crumb of crumbs; let last = last\"\n    [ngSwitch]=\"!!crumb.link\"\n    fxLayout=\"row\"\n    fxLayoutAlign=\"start center\"\n  >\n    <a *ngSwitchCase=\"true\" class=\"crumb link\" [routerLink]=\"[crumb.link]\">{{ crumb.name }}</a>\n    <div *ngSwitchDefault class=\"link\">{{ crumb.name }}</div>\n    <mat-icon *ngIf=\"!last\" class=\"chevron\">chevron_right</mat-icon>\n  </div>\n</div>\n"],"sourceRoot":""}